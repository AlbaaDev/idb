/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { isStateOperator, isPredicate, isNumber, invalidIndex } from './utils';
/**
 * @template T
 * @param {?} selector - Index of item in the array or a predicate function
 * that can be provided in `Array.prototype.findIndex`
 * @param {?} operatorOrValue - New value under the `selector` index or a
 * function that can be applied to an existing value
 * @return {?}
 */
export function updateItem(selector, operatorOrValue) {
    return (/**
     * @param {?} existing
     * @return {?}
     */
    function updateItemOperator(existing) {
        /** @type {?} */
        var index = -1;
        if (isPredicate(selector)) {
            index = existing.findIndex((/** @type {?} */ (selector)));
        }
        else if (isNumber(selector)) {
            index = selector;
        }
        if (invalidIndex(index)) {
            return (/** @type {?} */ (existing));
        }
        /** @type {?} */
        var value = (/** @type {?} */ (null));
        // Need to check if the new item value will change the existing item value
        // then, only if it will change it then clone the array and set the item
        /** @type {?} */
        var theOperatorOrValue = (/** @type {?} */ (operatorOrValue));
        if (isStateOperator(theOperatorOrValue)) {
            value = theOperatorOrValue((/** @type {?} */ (existing[index])));
        }
        else {
            value = theOperatorOrValue;
        }
        // If the value hasn't been mutated
        // then we just return `existing` array
        if (value === existing[index]) {
            return (/** @type {?} */ (existing));
        }
        /** @type {?} */
        var clone = existing.slice();
        clone[index] = (/** @type {?} */ (value));
        return clone;
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXBkYXRlLWl0ZW0uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4cy9zdG9yZS9vcGVyYXRvcnMvIiwic291cmNlcyI6WyJ1cGRhdGUtaXRlbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBRUEsT0FBTyxFQUNMLGVBQWUsRUFDZixXQUFXLEVBQ1gsUUFBUSxFQUNSLFlBQVksRUFHYixNQUFNLFNBQVMsQ0FBQzs7Ozs7Ozs7O0FBU2pCLE1BQU0sVUFBVSxVQUFVLENBQ3hCLFFBQXdDLEVBQ3hDLGVBQXVEO0lBRXZEOzs7O0lBQU8sU0FBUyxrQkFBa0IsQ0FBQyxRQUFtQzs7WUFDaEUsS0FBSyxHQUFHLENBQUMsQ0FBQztRQUVkLElBQUksV0FBVyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ3pCLEtBQUssR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLG1CQUFBLFFBQVEsRUFBZ0IsQ0FBQyxDQUFDO1NBQ3REO2FBQU0sSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDN0IsS0FBSyxHQUFHLFFBQVEsQ0FBQztTQUNsQjtRQUVELElBQUksWUFBWSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3ZCLE9BQU8sbUJBQUEsUUFBUSxFQUFtQixDQUFDO1NBQ3BDOztZQUVHLEtBQUssR0FBTSxtQkFBQSxJQUFJLEVBQUM7Ozs7WUFHZCxrQkFBa0IsR0FBRyxtQkFBQSxlQUFlLEVBQXdCO1FBQ2xFLElBQUksZUFBZSxDQUFDLGtCQUFrQixDQUFDLEVBQUU7WUFDdkMsS0FBSyxHQUFHLGtCQUFrQixDQUFDLG1CQUFBLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBZSxDQUFDLENBQUM7U0FDNUQ7YUFBTTtZQUNMLEtBQUssR0FBRyxrQkFBa0IsQ0FBQztTQUM1QjtRQUVELG1DQUFtQztRQUNuQyx1Q0FBdUM7UUFDdkMsSUFBSSxLQUFLLEtBQUssUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzdCLE9BQU8sbUJBQUEsUUFBUSxFQUFtQixDQUFDO1NBQ3BDOztZQUVLLEtBQUssR0FBRyxRQUFRLENBQUMsS0FBSyxFQUFFO1FBQzlCLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxtQkFBQSxLQUFLLEVBQWlCLENBQUM7UUFDdEMsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDLEVBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3RhdGVPcGVyYXRvciB9IGZyb20gJ0BuZ3hzL3N0b3JlJztcblxuaW1wb3J0IHtcbiAgaXNTdGF0ZU9wZXJhdG9yLFxuICBpc1ByZWRpY2F0ZSxcbiAgaXNOdW1iZXIsXG4gIGludmFsaWRJbmRleCxcbiAgUmVwYWlyVHlwZSxcbiAgTm9JbmZlclxufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IFByZWRpY2F0ZSB9IGZyb20gJy4vaW50ZXJuYWxzJztcblxuLyoqXG4gKiBAcGFyYW0gc2VsZWN0b3IgLSBJbmRleCBvZiBpdGVtIGluIHRoZSBhcnJheSBvciBhIHByZWRpY2F0ZSBmdW5jdGlvblxuICogdGhhdCBjYW4gYmUgcHJvdmlkZWQgaW4gYEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhgXG4gKiBAcGFyYW0gb3BlcmF0b3JPclZhbHVlIC0gTmV3IHZhbHVlIHVuZGVyIHRoZSBgc2VsZWN0b3JgIGluZGV4IG9yIGFcbiAqIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gYW4gZXhpc3RpbmcgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUl0ZW08VD4oXG4gIHNlbGVjdG9yOiBudW1iZXIgfCBOb0luZmVyPFByZWRpY2F0ZTxUPj4sXG4gIG9wZXJhdG9yT3JWYWx1ZTogTm9JbmZlcjxUPiB8IE5vSW5mZXI8U3RhdGVPcGVyYXRvcjxUPj5cbik6IFN0YXRlT3BlcmF0b3I8UmVwYWlyVHlwZTxUPltdPiB7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVJdGVtT3BlcmF0b3IoZXhpc3Rpbmc6IFJlYWRvbmx5PFJlcGFpclR5cGU8VD5bXT4pOiBSZXBhaXJUeXBlPFQ+W10ge1xuICAgIGxldCBpbmRleCA9IC0xO1xuXG4gICAgaWYgKGlzUHJlZGljYXRlKHNlbGVjdG9yKSkge1xuICAgICAgaW5kZXggPSBleGlzdGluZy5maW5kSW5kZXgoc2VsZWN0b3IgYXMgUHJlZGljYXRlPFQ+KTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKHNlbGVjdG9yKSkge1xuICAgICAgaW5kZXggPSBzZWxlY3RvcjtcbiAgICB9XG5cbiAgICBpZiAoaW52YWxpZEluZGV4KGluZGV4KSkge1xuICAgICAgcmV0dXJuIGV4aXN0aW5nIGFzIFJlcGFpclR5cGU8VD5bXTtcbiAgICB9XG5cbiAgICBsZXQgdmFsdWU6IFQgPSBudWxsITtcbiAgICAvLyBOZWVkIHRvIGNoZWNrIGlmIHRoZSBuZXcgaXRlbSB2YWx1ZSB3aWxsIGNoYW5nZSB0aGUgZXhpc3RpbmcgaXRlbSB2YWx1ZVxuICAgIC8vIHRoZW4sIG9ubHkgaWYgaXQgd2lsbCBjaGFuZ2UgaXQgdGhlbiBjbG9uZSB0aGUgYXJyYXkgYW5kIHNldCB0aGUgaXRlbVxuICAgIGNvbnN0IHRoZU9wZXJhdG9yT3JWYWx1ZSA9IG9wZXJhdG9yT3JWYWx1ZSBhcyBUIHwgU3RhdGVPcGVyYXRvcjxUPjtcbiAgICBpZiAoaXNTdGF0ZU9wZXJhdG9yKHRoZU9wZXJhdG9yT3JWYWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdGhlT3BlcmF0b3JPclZhbHVlKGV4aXN0aW5nW2luZGV4XSBhcyBSZWFkb25seTxUPik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gdGhlT3BlcmF0b3JPclZhbHVlO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSB2YWx1ZSBoYXNuJ3QgYmVlbiBtdXRhdGVkXG4gICAgLy8gdGhlbiB3ZSBqdXN0IHJldHVybiBgZXhpc3RpbmdgIGFycmF5XG4gICAgaWYgKHZhbHVlID09PSBleGlzdGluZ1tpbmRleF0pIHtcbiAgICAgIHJldHVybiBleGlzdGluZyBhcyBSZXBhaXJUeXBlPFQ+W107XG4gICAgfVxuXG4gICAgY29uc3QgY2xvbmUgPSBleGlzdGluZy5zbGljZSgpO1xuICAgIGNsb25lW2luZGV4XSA9IHZhbHVlIGFzIFJlcGFpclR5cGU8VD47XG4gICAgcmV0dXJuIGNsb25lO1xuICB9O1xufVxuIl19