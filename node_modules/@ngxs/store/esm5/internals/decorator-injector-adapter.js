/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { INJECTOR, ɵɵdirectiveInject, ɵglobal } from '@angular/core';
import { ReplaySubject } from 'rxjs';
// Angular doesn't export `NG_FACTORY_DEF`.
/** @type {?} */
var NG_FACTORY_DEF = 'ɵfac';
// A `Symbol` which is used to save the `Injector` onto the class instance.
/** @type {?} */
var InjectorInstance = Symbol('InjectorInstance');
// A `Symbol` which is used to determine if factory has been decorated previously or not.
/** @type {?} */
var FactoryHasBeenDecorated = Symbol('FactoryHasBeenDecorated');
// A `Symbol` which is used to save the notifier on the class instance. The `InjectorInstance` cannot
// be retrieved within the `constructor` since it's set after the `factory()` is called.
/** @type {?} */
var InjectorNotifier = Symbol('InjectorNotifier');
/**
 * @record
 */
function PrototypeWithInjectorNotifier() { }
if (false) {
    /* Skipping unnamed member:
    [InjectorNotifier]?: ReplaySubject<boolean>;*/
}
/**
 * @param {?} target
 * @return {?}
 */
export function ensureInjectorNotifierIsCaptured(target) {
    if (target[InjectorNotifier]) {
        return (/** @type {?} */ (target[InjectorNotifier]));
    }
    else {
        /** @type {?} */
        var injectorNotifier$_1 = new ReplaySubject(1);
        Object.defineProperty(target, InjectorNotifier, {
            get: (/**
             * @return {?}
             */
            function () { return injectorNotifier$_1; })
        });
        return injectorNotifier$_1;
    }
}
// eslint-disable-next-line @typescript-eslint/ban-types
/**
 * @param {?} target
 * @return {?}
 */
export function ensureLocalInjectorCaptured(target) {
    if (FactoryHasBeenDecorated in target.constructor.prototype) {
        return;
    }
    /** @type {?} */
    var constructor = target.constructor;
    // Means we're in AOT mode.
    if (typeof constructor[NG_FACTORY_DEF] === 'function') {
        decorateFactory(constructor);
    }
    else if (ngDevMode) {
        // We're running in JIT mode and that means we're not able to get the compiled definition
        // on the class inside the property decorator during the current message loop tick. We have
        // to wait for the next message loop tick. Note that this is safe since this Promise will be
        // resolved even before the `APP_INITIALIZER` is resolved.
        // The below code also will be executed only in development mode, since it's never recommended
        // to use the JIT compiler in production mode (by setting "aot: false").
        decorateFactoryLater(constructor);
    }
    target.constructor.prototype[FactoryHasBeenDecorated] = true;
}
/**
 * @template T
 * @param {?} instance
 * @param {?} token
 * @return {?}
 */
export function localInject(instance, token) {
    /** @type {?} */
    var injector = instance[InjectorInstance];
    return injector ? injector.get(token) : null;
}
/**
 * @param {?} constructor
 * @return {?}
 */
function decorateFactory(constructor) {
    /** @type {?} */
    var factory = constructor[NG_FACTORY_DEF];
    if (typeof factory !== 'function') {
        return;
    }
    // Let's try to get any definition.
    // Caretaker note: this will be compatible only with Angular 9+, since Angular 9 is the first
    // Ivy-stable version. Previously definition properties were named differently (e.g. `ngComponentDef`).
    /** @type {?} */
    var def = constructor.ɵprov || constructor.ɵpipe || constructor.ɵcmp || constructor.ɵdir;
    /** @type {?} */
    var decoratedFactory = (/**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var instance = factory();
        // Caretaker note: `inject()` won't work here.
        // We can use the `directiveInject` only during the component
        // construction, since Angular captures the currently active injector.
        // We're not able to use this function inside the getter (when the `selectorId` property is
        // requested for the first time), since the currently active injector will be null.
        instance[InjectorInstance] = ɵɵdirectiveInject(
        // We're using `INJECTOR` token except of the `Injector` class since the compiler
        // throws: `Cannot assign an abstract constructor type to a non-abstract constructor type.`.
        // Caretaker note: that this is the same way of getting the injector.
        INJECTOR);
        // Caretaker note: the notifier will be available only if consumers call the `ensureInjectorNotifierIsCaptured()`.
        /** @type {?} */
        var injectorNotifier$ = instance[InjectorNotifier];
        if (injectorNotifier$) {
            injectorNotifier$.next(true);
            injectorNotifier$.complete();
        }
        return instance;
    });
    // If we've found any definition then it's enough to override the `def.factory` since Angular
    // code uses the `def.factory` and then fallbacks to `ɵfac`.
    if (def) {
        def.factory = decoratedFactory;
    }
    // `@NgModule()` doesn't doesn't have definition factory, also providers have definitions but Angular
    // still uses the `ɵfac`.
    Object.defineProperty(constructor, NG_FACTORY_DEF, {
        get: (/**
         * @return {?}
         */
        function () { return decoratedFactory; })
    });
}
/**
 * @param {?} constructor
 * @return {?}
 */
function decorateFactoryLater(constructor) {
    // This function actually will be tree-shaken away when building for production since it's guarded with `ngDevMode`.
    // We're having the `try-catch` here because of the `SyncTestZoneSpec`, which throws
    // an error when micro or macrotask is used within a synchronous test. E.g. `Cannot call
    // Promise.then from within a sync test`.
    try {
        Promise.resolve().then((/**
         * @return {?}
         */
        function () {
            decorateFactory(constructor);
        }));
    }
    catch (_a) {
        // This is kind of a "hack", but we try to be backwards-compatible,
        // tho this `catch` block will only be executed when tests are run with Jasmine or Jest.
        ɵglobal.process &&
            ɵglobal.process.nextTick &&
            ɵglobal.process.nextTick((/**
             * @return {?}
             */
            function () {
                decorateFactory(constructor);
            }));
    }
}
/**
 * @record
 */
function Definition() { }
if (false) {
    /** @type {?} */
    Definition.prototype.factory;
}
/**
 * @record
 */
function ConstructorWithDefinitionAndFactory() { }
if (false) {
    /** @type {?|undefined} */
    ConstructorWithDefinitionAndFactory.prototype.ɵprov;
    /** @type {?|undefined} */
    ConstructorWithDefinitionAndFactory.prototype.ɵpipe;
    /** @type {?|undefined} */
    ConstructorWithDefinitionAndFactory.prototype.ɵcmp;
    /** @type {?|undefined} */
    ConstructorWithDefinitionAndFactory.prototype.ɵdir;
    /* Skipping unnamed member:
    [NG_FACTORY_DEF]?: Factory;*/
}
/**
 * @record
 */
function PrivateInstance() { }
if (false) {
    /* Skipping unnamed member:
    [InjectorInstance]?: Injector;*/
    /* Skipping unnamed member:
    [InjectorNotifier]?: ReplaySubject<boolean>;*/
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjb3JhdG9yLWluamVjdG9yLWFkYXB0ZXIuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4cy9zdG9yZS9pbnRlcm5hbHMvIiwic291cmNlcyI6WyJkZWNvcmF0b3ItaW5qZWN0b3ItYWRhcHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUdMLFFBQVEsRUFFUixpQkFBaUIsRUFDakIsT0FBTyxFQUNSLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxNQUFNLENBQUM7OztJQU8vQixjQUFjLEdBQUcsTUFBTTs7O0lBR3ZCLGdCQUFnQixHQUFrQixNQUFNLENBQUMsa0JBQWtCLENBQUM7OztJQUc1RCx1QkFBdUIsR0FBa0IsTUFBTSxDQUFDLHlCQUF5QixDQUFDOzs7O0lBSTFFLGdCQUFnQixHQUFrQixNQUFNLENBQUMsa0JBQWtCLENBQUM7Ozs7QUFFbEUsNENBRUM7Ozs7Ozs7OztBQUVELE1BQU0sVUFBVSxnQ0FBZ0MsQ0FDOUMsTUFBdUQ7SUFFdkQsSUFBSSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtRQUM1QixPQUFPLG1CQUFBLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFDLENBQUM7S0FDbEM7U0FBTTs7WUFDQyxtQkFBaUIsR0FBRyxJQUFJLGFBQWEsQ0FBVSxDQUFDLENBQUM7UUFDdkQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLEVBQUU7WUFDOUMsR0FBRzs7O1lBQUUsY0FBTSxPQUFBLG1CQUFpQixFQUFqQixDQUFpQixDQUFBO1NBQzdCLENBQUMsQ0FBQztRQUNILE9BQU8sbUJBQWlCLENBQUM7S0FDMUI7QUFDSCxDQUFDOzs7Ozs7QUFHRCxNQUFNLFVBQVUsMkJBQTJCLENBQUMsTUFBYztJQUN4RCxJQUFJLHVCQUF1QixJQUFJLE1BQU0sQ0FBQyxXQUFXLENBQUMsU0FBUyxFQUFFO1FBQzNELE9BQU87S0FDUjs7UUFFSyxXQUFXLEdBQXdDLE1B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OztJQUVuQixvREFBbUI7O0lBRW5CLG1EQUFrQjs7SUFFbEIsbURBQWtCOzs7Ozs7O0FBSXBCLDhCQUdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSW5qZWN0aW9uVG9rZW4sXG4gIEluamVjdG9yLFxuICBJTkpFQ1RPUixcbiAgVHlwZSxcbiAgybXJtWRpcmVjdGl2ZUluamVjdCxcbiAgybVnbG9iYWxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSZXBsYXlTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbi8vIFdpbGwgYmUgcHJvdmlkZWQgdGhyb3VnaCBUZXJzZXIgZ2xvYmFsIGRlZmluaXRpb25zIGJ5IEFuZ3VsYXIgQ0xJXG4vLyBkdXJpbmcgdGhlIHByb2R1Y3Rpb24gYnVpbGQuIFRoaXMgaXMgaG93IEFuZ3VsYXIgZG9lcyB0cmVlLXNoYWtpbmcgaW50ZXJuYWxseS5cbmRlY2xhcmUgY29uc3QgbmdEZXZNb2RlOiBib29sZWFuO1xuXG4vLyBBbmd1bGFyIGRvZXNuJ3QgZXhwb3J0IGBOR19GQUNUT1JZX0RFRmAuXG5jb25zdCBOR19GQUNUT1JZX0RFRiA9ICfJtWZhYyc7XG5cbi8vIEEgYFN5bWJvbGAgd2hpY2ggaXMgdXNlZCB0byBzYXZlIHRoZSBgSW5qZWN0b3JgIG9udG8gdGhlIGNsYXNzIGluc3RhbmNlLlxuY29uc3QgSW5qZWN0b3JJbnN0YW5jZTogdW5pcXVlIHN5bWJvbCA9IFN5bWJvbCgnSW5qZWN0b3JJbnN0YW5jZScpO1xuXG4vLyBBIGBTeW1ib2xgIHdoaWNoIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGZhY3RvcnkgaGFzIGJlZW4gZGVjb3JhdGVkIHByZXZpb3VzbHkgb3Igbm90LlxuY29uc3QgRmFjdG9yeUhhc0JlZW5EZWNvcmF0ZWQ6IHVuaXF1ZSBzeW1ib2wgPSBTeW1ib2woJ0ZhY3RvcnlIYXNCZWVuRGVjb3JhdGVkJyk7XG5cbi8vIEEgYFN5bWJvbGAgd2hpY2ggaXMgdXNlZCB0byBzYXZlIHRoZSBub3RpZmllciBvbiB0aGUgY2xhc3MgaW5zdGFuY2UuIFRoZSBgSW5qZWN0b3JJbnN0YW5jZWAgY2Fubm90XG4vLyBiZSByZXRyaWV2ZWQgd2l0aGluIHRoZSBgY29uc3RydWN0b3JgIHNpbmNlIGl0J3Mgc2V0IGFmdGVyIHRoZSBgZmFjdG9yeSgpYCBpcyBjYWxsZWQuXG5jb25zdCBJbmplY3Rvck5vdGlmaWVyOiB1bmlxdWUgc3ltYm9sID0gU3ltYm9sKCdJbmplY3Rvck5vdGlmaWVyJyk7XG5cbmludGVyZmFjZSBQcm90b3R5cGVXaXRoSW5qZWN0b3JOb3RpZmllciBleHRlbmRzIE9iamVjdCB7XG4gIFtJbmplY3Rvck5vdGlmaWVyXT86IFJlcGxheVN1YmplY3Q8Ym9vbGVhbj47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVJbmplY3Rvck5vdGlmaWVySXNDYXB0dXJlZChcbiAgdGFyZ2V0OiBQcm90b3R5cGVXaXRoSW5qZWN0b3JOb3RpZmllciB8IFByaXZhdGVJbnN0YW5jZVxuKTogUmVwbGF5U3ViamVjdDxib29sZWFuPiB7XG4gIGlmICh0YXJnZXRbSW5qZWN0b3JOb3RpZmllcl0pIHtcbiAgICByZXR1cm4gdGFyZ2V0W0luamVjdG9yTm90aWZpZXJdITtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpbmplY3Rvck5vdGlmaWVyJCA9IG5ldyBSZXBsYXlTdWJqZWN0PGJvb2xlYW4+KDEpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIEluamVjdG9yTm90aWZpZXIsIHtcbiAgICAgIGdldDogKCkgPT4gaW5qZWN0b3JOb3RpZmllciRcbiAgICB9KTtcbiAgICByZXR1cm4gaW5qZWN0b3JOb3RpZmllciQ7XG4gIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVMb2NhbEluamVjdG9yQ2FwdHVyZWQodGFyZ2V0OiBPYmplY3QpOiB2b2lkIHtcbiAgaWYgKEZhY3RvcnlIYXNCZWVuRGVjb3JhdGVkIGluIHRhcmdldC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBjb25zdHJ1Y3RvcjogQ29uc3RydWN0b3JXaXRoRGVmaW5pdGlvbkFuZEZhY3RvcnkgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIC8vIE1lYW5zIHdlJ3JlIGluIEFPVCBtb2RlLlxuICBpZiAodHlwZW9mIGNvbnN0cnVjdG9yW05HX0ZBQ1RPUllfREVGXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRlY29yYXRlRmFjdG9yeShjb25zdHJ1Y3Rvcik7XG4gIH0gZWxzZSBpZiAobmdEZXZNb2RlKSB7XG4gICAgLy8gV2UncmUgcnVubmluZyBpbiBKSVQgbW9kZSBhbmQgdGhhdCBtZWFucyB3ZSdyZSBub3QgYWJsZSB0byBnZXQgdGhlIGNvbXBpbGVkIGRlZmluaXRpb25cbiAgICAvLyBvbiB0aGUgY2xhc3MgaW5zaWRlIHRoZSBwcm9wZXJ0eSBkZWNvcmF0b3IgZHVyaW5nIHRoZSBjdXJyZW50IG1lc3NhZ2UgbG9vcCB0aWNrLiBXZSBoYXZlXG4gICAgLy8gdG8gd2FpdCBmb3IgdGhlIG5leHQgbWVzc2FnZSBsb29wIHRpY2suIE5vdGUgdGhhdCB0aGlzIGlzIHNhZmUgc2luY2UgdGhpcyBQcm9taXNlIHdpbGwgYmVcbiAgICAvLyByZXNvbHZlZCBldmVuIGJlZm9yZSB0aGUgYEFQUF9JTklUSUFMSVpFUmAgaXMgcmVzb2x2ZWQuXG4gICAgLy8gVGhlIGJlbG93IGNvZGUgYWxzbyB3aWxsIGJlIGV4ZWN1dGVkIG9ubHkgaW4gZGV2ZWxvcG1lbnQgbW9kZSwgc2luY2UgaXQncyBuZXZlciByZWNvbW1lbmRlZFxuICAgIC8vIHRvIHVzZSB0aGUgSklUIGNvbXBpbGVyIGluIHByb2R1Y3Rpb24gbW9kZSAoYnkgc2V0dGluZyBcImFvdDogZmFsc2VcIikuXG4gICAgZGVjb3JhdGVGYWN0b3J5TGF0ZXIoY29uc3RydWN0b3IpO1xuICB9XG5cbiAgdGFyZ2V0LmNvbnN0cnVjdG9yLnByb3RvdHlwZVtGYWN0b3J5SGFzQmVlbkRlY29yYXRlZF0gPSB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9jYWxJbmplY3Q8VD4oXG4gIGluc3RhbmNlOiBQcml2YXRlSW5zdGFuY2UsXG4gIHRva2VuOiBJbmplY3Rpb25Ub2tlbjxUPiB8IFR5cGU8VD5cbik6IFQgfCBudWxsIHtcbiAgY29uc3QgaW5qZWN0b3I6IEluamVjdG9yIHwgdW5kZWZpbmVkID0gaW5zdGFuY2VbSW5qZWN0b3JJbnN0YW5jZV07XG4gIHJldHVybiBpbmplY3RvciA/IGluamVjdG9yLmdldCh0b2tlbikgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBkZWNvcmF0ZUZhY3RvcnkoY29uc3RydWN0b3I6IENvbnN0cnVjdG9yV2l0aERlZmluaXRpb25BbmRGYWN0b3J5KTogdm9pZCB7XG4gIGNvbnN0IGZhY3RvcnkgPSBjb25zdHJ1Y3RvcltOR19GQUNUT1JZX0RFRl07XG5cbiAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gTGV0J3MgdHJ5IHRvIGdldCBhbnkgZGVmaW5pdGlvbi5cbiAgLy8gQ2FyZXRha2VyIG5vdGU6IHRoaXMgd2lsbCBiZSBjb21wYXRpYmxlIG9ubHkgd2l0aCBBbmd1bGFyIDkrLCBzaW5jZSBBbmd1bGFyIDkgaXMgdGhlIGZpcnN0XG4gIC8vIEl2eS1zdGFibGUgdmVyc2lvbi4gUHJldmlvdXNseSBkZWZpbml0aW9uIHByb3BlcnRpZXMgd2VyZSBuYW1lZCBkaWZmZXJlbnRseSAoZS5nLiBgbmdDb21wb25lbnREZWZgKS5cbiAgY29uc3QgZGVmID0gY29uc3RydWN0b3IuybVwcm92IHx8IGNvbnN0cnVjdG9yLsm1cGlwZSB8fCBjb25zdHJ1Y3Rvci7JtWNtcCB8fCBjb25zdHJ1Y3Rvci7JtWRpcjtcblxuICBjb25zdCBkZWNvcmF0ZWRGYWN0b3J5ID0gKCkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZmFjdG9yeSgpO1xuICAgIC8vIENhcmV0YWtlciBub3RlOiBgaW5qZWN0KClgIHdvbid0IHdvcmsgaGVyZS5cbiAgICAvLyBXZSBjYW4gdXNlIHRoZSBgZGlyZWN0aXZlSW5qZWN0YCBvbmx5IGR1cmluZyB0aGUgY29tcG9uZW50XG4gICAgLy8gY29uc3RydWN0aW9uLCBzaW5jZSBBbmd1bGFyIGNhcHR1cmVzIHRoZSBjdXJyZW50bHkgYWN0aXZlIGluamVjdG9yLlxuICAgIC8vIFdlJ3JlIG5vdCBhYmxlIHRvIHVzZSB0aGlzIGZ1bmN0aW9uIGluc2lkZSB0aGUgZ2V0dGVyICh3aGVuIHRoZSBgc2VsZWN0b3JJZGAgcHJvcGVydHkgaXNcbiAgICAvLyByZXF1ZXN0ZWQgZm9yIHRoZSBmaXJzdCB0aW1lKSwgc2luY2UgdGhlIGN1cnJlbnRseSBhY3RpdmUgaW5qZWN0b3Igd2lsbCBiZSBudWxsLlxuICAgIGluc3RhbmNlW0luamVjdG9ySW5zdGFuY2VdID0gybXJtWRpcmVjdGl2ZUluamVjdChcbiAgICAgIC8vIFdlJ3JlIHVzaW5nIGBJTkpFQ1RPUmAgdG9rZW4gZXhjZXB0IG9mIHRoZSBgSW5qZWN0b3JgIGNsYXNzIHNpbmNlIHRoZSBjb21waWxlclxuICAgICAgLy8gdGhyb3dzOiBgQ2Fubm90IGFzc2lnbiBhbiBhYnN0cmFjdCBjb25zdHJ1Y3RvciB0eXBlIHRvIGEgbm9uLWFic3RyYWN0IGNvbnN0cnVjdG9yIHR5cGUuYC5cbiAgICAgIC8vIENhcmV0YWtlciBub3RlOiB0aGF0IHRoaXMgaXMgdGhlIHNhbWUgd2F5IG9mIGdldHRpbmcgdGhlIGluamVjdG9yLlxuICAgICAgSU5KRUNUT1JcbiAgICApO1xuXG4gICAgLy8gQ2FyZXRha2VyIG5vdGU6IHRoZSBub3RpZmllciB3aWxsIGJlIGF2YWlsYWJsZSBvbmx5IGlmIGNvbnN1bWVycyBjYWxsIHRoZSBgZW5zdXJlSW5qZWN0b3JOb3RpZmllcklzQ2FwdHVyZWQoKWAuXG4gICAgY29uc3QgaW5qZWN0b3JOb3RpZmllciQgPSBpbnN0YW5jZVtJbmplY3Rvck5vdGlmaWVyXTtcbiAgICBpZiAoaW5qZWN0b3JOb3RpZmllciQpIHtcbiAgICAgIGluamVjdG9yTm90aWZpZXIkLm5leHQodHJ1ZSk7XG4gICAgICBpbmplY3Rvck5vdGlmaWVyJC5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBJZiB3ZSd2ZSBmb3VuZCBhbnkgZGVmaW5pdGlvbiB0aGVuIGl0J3MgZW5vdWdoIHRvIG92ZXJyaWRlIHRoZSBgZGVmLmZhY3RvcnlgIHNpbmNlIEFuZ3VsYXJcbiAgLy8gY29kZSB1c2VzIHRoZSBgZGVmLmZhY3RvcnlgIGFuZCB0aGVuIGZhbGxiYWNrcyB0byBgybVmYWNgLlxuICBpZiAoZGVmKSB7XG4gICAgZGVmLmZhY3RvcnkgPSBkZWNvcmF0ZWRGYWN0b3J5O1xuICB9XG5cbiAgLy8gYEBOZ01vZHVsZSgpYCBkb2Vzbid0IGRvZXNuJ3QgaGF2ZSBkZWZpbml0aW9uIGZhY3RvcnksIGFsc28gcHJvdmlkZXJzIGhhdmUgZGVmaW5pdGlvbnMgYnV0IEFuZ3VsYXJcbiAgLy8gc3RpbGwgdXNlcyB0aGUgYMm1ZmFjYC5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCBOR19GQUNUT1JZX0RFRiwge1xuICAgIGdldDogKCkgPT4gZGVjb3JhdGVkRmFjdG9yeVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVjb3JhdGVGYWN0b3J5TGF0ZXIoY29uc3RydWN0b3I6IENvbnN0cnVjdG9yV2l0aERlZmluaXRpb25BbmRGYWN0b3J5KTogdm9pZCB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gYWN0dWFsbHkgd2lsbCBiZSB0cmVlLXNoYWtlbiBhd2F5IHdoZW4gYnVpbGRpbmcgZm9yIHByb2R1Y3Rpb24gc2luY2UgaXQncyBndWFyZGVkIHdpdGggYG5nRGV2TW9kZWAuXG4gIC8vIFdlJ3JlIGhhdmluZyB0aGUgYHRyeS1jYXRjaGAgaGVyZSBiZWNhdXNlIG9mIHRoZSBgU3luY1Rlc3Rab25lU3BlY2AsIHdoaWNoIHRocm93c1xuICAvLyBhbiBlcnJvciB3aGVuIG1pY3JvIG9yIG1hY3JvdGFzayBpcyB1c2VkIHdpdGhpbiBhIHN5bmNocm9ub3VzIHRlc3QuIEUuZy4gYENhbm5vdCBjYWxsXG4gIC8vIFByb21pc2UudGhlbiBmcm9tIHdpdGhpbiBhIHN5bmMgdGVzdGAuXG4gIHRyeSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICBkZWNvcmF0ZUZhY3RvcnkoY29uc3RydWN0b3IpO1xuICAgIH0pO1xuICB9IGNhdGNoIHtcbiAgICAvLyBUaGlzIGlzIGtpbmQgb2YgYSBcImhhY2tcIiwgYnV0IHdlIHRyeSB0byBiZSBiYWNrd2FyZHMtY29tcGF0aWJsZSxcbiAgICAvLyB0aG8gdGhpcyBgY2F0Y2hgIGJsb2NrIHdpbGwgb25seSBiZSBleGVjdXRlZCB3aGVuIHRlc3RzIGFyZSBydW4gd2l0aCBKYXNtaW5lIG9yIEplc3QuXG4gICAgybVnbG9iYWwucHJvY2VzcyAmJlxuICAgICAgybVnbG9iYWwucHJvY2Vzcy5uZXh0VGljayAmJlxuICAgICAgybVnbG9iYWwucHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGRlY29yYXRlRmFjdG9yeShjb25zdHJ1Y3Rvcik7XG4gICAgICB9KTtcbiAgfVxufVxuXG4vLyBXZSBjb3VsZCd2ZSB1c2VkIGDJtcm1RmFjdG9yeURlZmAgYnV0IHdlIHRyeSB0byBiZSBiYWNrd2FyZHMtY29tcGF0aWJsZSxcbi8vIHNpbmNlIGl0J3Mgbm90IGV4cG9ydGVkIGluIG9sZGVyIEFuZ3VsYXIgdmVyc2lvbnMuXG50eXBlIEZhY3RvcnkgPSAoKSA9PiBQcml2YXRlSW5zdGFuY2U7XG5cbi8vIFdlIGNvdWxkJ3ZlIHVzZWQgYMm1ybVJbmplY3RhYmxlRGVmYCwgYMm1ybVQaXBlRGVmYCwgZXRjLiBXZSB0cnkgdG8gYmUgYmFja3dhcmRzLWNvbXBhdGlibGVcbi8vIHNpbmNlIHRoZXkncmUgbm90IGV4cG9ydGVkIGluIG9sZGVyIEFuZ3VsYXIgdmVyc2lvbnMuXG5pbnRlcmZhY2UgRGVmaW5pdGlvbiB7XG4gIGZhY3Rvcnk6IEZhY3RvcnkgfCBudWxsO1xufVxuXG5pbnRlcmZhY2UgQ29uc3RydWN0b3JXaXRoRGVmaW5pdGlvbkFuZEZhY3RvcnkgZXh0ZW5kcyBGdW5jdGlvbiB7XG4gIC8vIFByb3ZpZGVyIGRlZmluaXRpb24gZm9yIHRoZSBgQEluamVjdGFibGUoKWAgY2xhc3MuXG4gIMm1cHJvdj86IERlZmluaXRpb247XG4gIC8vIFBpcGUgZGVmaW5pdGlvbiBmb3IgdGhlIGBAUGlwZSgpYCBjbGFzcy5cbiAgybVwaXBlPzogRGVmaW5pdGlvbjtcbiAgLy8gQ29tcG9uZW50IGRlZmluaXRpb24gZm9yIHRoZSBgQENvbXBvbmVudCgpYCBjbGFzcy5cbiAgybVjbXA/OiBEZWZpbml0aW9uO1xuICAvLyBEaXJlY3RpdmUgZGVmaW5pdGlvbiBmb3IgdGhlIGBARGlyZWN0aXZlKClgIGNsYXNzLlxuICDJtWRpcj86IERlZmluaXRpb247XG4gIFtOR19GQUNUT1JZX0RFRl0/OiBGYWN0b3J5O1xufVxuXG5pbnRlcmZhY2UgUHJpdmF0ZUluc3RhbmNlIHtcbiAgW0luamVjdG9ySW5zdGFuY2VdPzogSW5qZWN0b3I7XG4gIFtJbmplY3Rvck5vdGlmaWVyXT86IFJlcGxheVN1YmplY3Q8Ym9vbGVhbj47XG59XG4iXX0=