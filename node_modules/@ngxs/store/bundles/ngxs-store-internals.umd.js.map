{"version":3,"file":"ngxs-store-internals.umd.js","sources":["ng://@ngxs/store/internals/memoize.ts","ng://@ngxs/store/internals/angular.ts","ng://@ngxs/store/internals/ngxs-bootstrapper.ts","ng://@ngxs/store/internals/initial-state.ts","ng://@ngxs/store/internals/internal-tokens.ts","ng://@ngxs/store/internals/decorator-injector-adapter.ts"],"sourcesContent":["function defaultEqualityCheck(a: any, b: any) {\n  return a === b;\n}\n\nfunction areArgumentsShallowlyEqual(\n  equalityCheck: (a: any, b: any) => boolean,\n  prev: IArguments | null,\n  next: IArguments | null\n) {\n  if (prev === null || next === null || prev.length !== next.length) {\n    return false;\n  }\n\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n  const length = prev.length;\n  for (let i = 0; i < length; i++) {\n    if (!equalityCheck(prev[i], next[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Memoize a function on its last inputs only.\n * Originally from: https://github.com/reduxjs/reselect/blob/master/src/index.js\n *\n * @ignore\n */\nexport function memoize<T extends (...args: any[]) => any>(\n  func: T,\n  equalityCheck = defaultEqualityCheck\n): T {\n  let lastArgs: IArguments | null = null;\n  let lastResult: any = null;\n  // we reference arguments instead of spreading them for performance reasons\n  function memoized() {\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\n      // apply arguments instead of spreading for performance.\n      lastResult = (<Function>func).apply(null, arguments);\n    }\n\n    lastArgs = arguments;\n    return lastResult;\n  }\n  (<any>memoized).reset = function() {\n    // The hidden (for now) ability to reset the memoization\n    lastArgs = null;\n    lastResult = null;\n  };\n  return memoized as T;\n}\n","import { getPlatform, COMPILER_OPTIONS, CompilerOptions, PlatformRef } from '@angular/core';\nimport { memoize } from './memoize';\n\n/**\n * @description Will be provided through Terser global definitions by Angular CLI\n * during the production build. This is how Angular does tree-shaking internally.\n */\ndeclare const ngDevMode: boolean;\n\nfunction _isAngularInTestMode(): boolean {\n  const platformRef: PlatformRef | null = getPlatform();\n  if (!platformRef) return false;\n  const compilerOptions = platformRef.injector.get(COMPILER_OPTIONS, null);\n  if (!compilerOptions) return false;\n  const isInTestMode = compilerOptions.some((item: CompilerOptions) => {\n    const providers = (item && item.providers) || [];\n    return providers.some((provider: any) => {\n      return (\n        (provider && provider.provide && provider.provide.name === 'MockNgModuleResolver') ||\n        false\n      );\n    });\n  });\n  return isInTestMode;\n}\n\nexport const isAngularInTestMode =\n  // Caretaker note: we have still left the `typeof` condition in order to avoid\n  // creating a breaking change for projects that still use the View Engine.\n  typeof ngDevMode === 'undefined' || ngDevMode ? memoize(_isAngularInTestMode) : () => false;\n","import { Injectable } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\n\n@Injectable()\nexport class NgxsBootstrapper {\n  /**\n   * Use `ReplaySubject`, thus we can get cached value even if the stream is completed\n   */\n  private bootstrap$ = new ReplaySubject<boolean>(1);\n\n  get appBootstrapped$(): Observable<boolean> {\n    return this.bootstrap$.asObservable();\n  }\n\n  /**\n   * This event will be emitted after attaching `ComponentRef` of the root component\n   * to the tree of views, that's a signal that application has been fully rendered\n   */\n  bootstrap(): void {\n    this.bootstrap$.next(true);\n    this.bootstrap$.complete();\n  }\n}\n","import { InjectionToken } from '@angular/core';\nimport { PlainObject } from './symbols';\n\nexport const INITIAL_STATE_TOKEN = new InjectionToken<any>('INITIAL_STATE_TOKEN');\n\nexport class InitialState {\n  private static value: PlainObject = {};\n\n  public static set(state: PlainObject) {\n    this.value = state;\n  }\n\n  public static pop(): PlainObject {\n    const state: PlainObject = this.value;\n    this.value = {};\n    return state;\n  }\n}\n","import { InjectionToken } from '@angular/core';\n\n/**\n * @see StateContextFactory as it's referenced by this token to be accessed by plugins internally\n */\nexport const NGXS_STATE_CONTEXT_FACTORY: InjectionToken<any> = new InjectionToken(\n  'Internals.StateContextFactory'\n);\n\n/**\n * @see StateFactory as it's referenced by this token to be accessed by plugins internally\n */\nexport const NGXS_STATE_FACTORY: InjectionToken<any> = new InjectionToken(\n  'Internals.StateFactory'\n);\n","import {\n  InjectionToken,\n  Injector,\n  INJECTOR,\n  Type,\n  ÉµÉµdirectiveInject,\n  Éµglobal\n} from '@angular/core';\nimport { ReplaySubject } from 'rxjs';\n\n// Will be provided through Terser global definitions by Angular CLI\n// during the production build. This is how Angular does tree-shaking internally.\ndeclare const ngDevMode: boolean;\n\n// Angular doesn't export `NG_FACTORY_DEF`.\nconst NG_FACTORY_DEF = 'Éµfac';\n\n// A `Symbol` which is used to save the `Injector` onto the class instance.\nconst InjectorInstance: unique symbol = Symbol('InjectorInstance');\n\n// A `Symbol` which is used to determine if factory has been decorated previously or not.\nconst FactoryHasBeenDecorated: unique symbol = Symbol('FactoryHasBeenDecorated');\n\n// A `Symbol` which is used to save the notifier on the class instance. The `InjectorInstance` cannot\n// be retrieved within the `constructor` since it's set after the `factory()` is called.\nconst InjectorNotifier: unique symbol = Symbol('InjectorNotifier');\n\ninterface PrototypeWithInjectorNotifier extends Object {\n  [InjectorNotifier]?: ReplaySubject<boolean>;\n}\n\nexport function ensureInjectorNotifierIsCaptured(\n  target: PrototypeWithInjectorNotifier | PrivateInstance\n): ReplaySubject<boolean> {\n  if (target[InjectorNotifier]) {\n    return target[InjectorNotifier]!;\n  } else {\n    const injectorNotifier$ = new ReplaySubject<boolean>(1);\n    Object.defineProperty(target, InjectorNotifier, {\n      get: () => injectorNotifier$\n    });\n    return injectorNotifier$;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function ensureLocalInjectorCaptured(target: Object): void {\n  if (FactoryHasBeenDecorated in target.constructor.prototype) {\n    return;\n  }\n\n  const constructor: ConstructorWithDefinitionAndFactory = target.constructor;\n  // Means we're in AOT mode.\n  if (typeof constructor[NG_FACTORY_DEF] === 'function') {\n    decorateFactory(constructor);\n  } else if (ngDevMode) {\n    // We're running in JIT mode and that means we're not able to get the compiled definition\n    // on the class inside the property decorator during the current message loop tick. We have\n    // to wait for the next message loop tick. Note that this is safe since this Promise will be\n    // resolved even before the `APP_INITIALIZER` is resolved.\n    // The below code also will be executed only in development mode, since it's never recommended\n    // to use the JIT compiler in production mode (by setting \"aot: false\").\n    decorateFactoryLater(constructor);\n  }\n\n  target.constructor.prototype[FactoryHasBeenDecorated] = true;\n}\n\nexport function localInject<T>(\n  instance: PrivateInstance,\n  token: InjectionToken<T> | Type<T>\n): T | null {\n  const injector: Injector | undefined = instance[InjectorInstance];\n  return injector ? injector.get(token) : null;\n}\n\nfunction decorateFactory(constructor: ConstructorWithDefinitionAndFactory): void {\n  const factory = constructor[NG_FACTORY_DEF];\n\n  if (typeof factory !== 'function') {\n    return;\n  }\n\n  // Let's try to get any definition.\n  // Caretaker note: this will be compatible only with Angular 9+, since Angular 9 is the first\n  // Ivy-stable version. Previously definition properties were named differently (e.g. `ngComponentDef`).\n  const def = constructor.Éµprov || constructor.Éµpipe || constructor.Éµcmp || constructor.Éµdir;\n\n  const decoratedFactory = () => {\n    const instance = factory();\n    // Caretaker note: `inject()` won't work here.\n    // We can use the `directiveInject` only during the component\n    // construction, since Angular captures the currently active injector.\n    // We're not able to use this function inside the getter (when the `selectorId` property is\n    // requested for the first time), since the currently active injector will be null.\n    instance[InjectorInstance] = ÉµÉµdirectiveInject(\n      // We're using `INJECTOR` token except of the `Injector` class since the compiler\n      // throws: `Cannot assign an abstract constructor type to a non-abstract constructor type.`.\n      // Caretaker note: that this is the same way of getting the injector.\n      INJECTOR\n    );\n\n    // Caretaker note: the notifier will be available only if consumers call the `ensureInjectorNotifierIsCaptured()`.\n    const injectorNotifier$ = instance[InjectorNotifier];\n    if (injectorNotifier$) {\n      injectorNotifier$.next(true);\n      injectorNotifier$.complete();\n    }\n\n    return instance;\n  };\n\n  // If we've found any definition then it's enough to override the `def.factory` since Angular\n  // code uses the `def.factory` and then fallbacks to `Éµfac`.\n  if (def) {\n    def.factory = decoratedFactory;\n  }\n\n  // `@NgModule()` doesn't doesn't have definition factory, also providers have definitions but Angular\n  // still uses the `Éµfac`.\n  Object.defineProperty(constructor, NG_FACTORY_DEF, {\n    get: () => decoratedFactory\n  });\n}\n\nfunction decorateFactoryLater(constructor: ConstructorWithDefinitionAndFactory): void {\n  // This function actually will be tree-shaken away when building for production since it's guarded with `ngDevMode`.\n  // We're having the `try-catch` here because of the `SyncTestZoneSpec`, which throws\n  // an error when micro or macrotask is used within a synchronous test. E.g. `Cannot call\n  // Promise.then from within a sync test`.\n  try {\n    Promise.resolve().then(() => {\n      decorateFactory(constructor);\n    });\n  } catch {\n    // This is kind of a \"hack\", but we try to be backwards-compatible,\n    // tho this `catch` block will only be executed when tests are run with Jasmine or Jest.\n    Éµglobal.process &&\n      Éµglobal.process.nextTick &&\n      Éµglobal.process.nextTick(() => {\n        decorateFactory(constructor);\n      });\n  }\n}\n\n// We could've used `ÉµÉµFactoryDef` but we try to be backwards-compatible,\n// since it's not exported in older Angular versions.\ntype Factory = () => PrivateInstance;\n\n// We could've used `ÉµÉµInjectableDef`, `ÉµÉµPipeDef`, etc. We try to be backwards-compatible\n// since they're not exported in older Angular versions.\ninterface Definition {\n  factory: Factory | null;\n}\n\ninterface ConstructorWithDefinitionAndFactory extends Function {\n  // Provider definition for the `@Injectable()` class.\n  Éµprov?: Definition;\n  // Pipe definition for the `@Pipe()` class.\n  Éµpipe?: Definition;\n  // Component definition for the `@Component()` class.\n  Éµcmp?: Definition;\n  // Directive definition for the `@Directive()` class.\n  Éµdir?: Definition;\n  [NG_FACTORY_DEF]?: Factory;\n}\n\ninterface PrivateInstance {\n  [InjectorInstance]?: Injector;\n  [InjectorNotifier]?: ReplaySubject<boolean>;\n}\n"],"names":["getPlatform","COMPILER_OPTIONS","ReplaySubject","Injectable","InjectionToken","ɵɵdirectiveInject","INJECTOR","ɵglobal"],"mappings":"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"}