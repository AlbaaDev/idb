/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, Injector, Optional, SkipSelf, Inject } from '@angular/core';
import { forkJoin, from, Observable, of, throwError, Subject } from 'rxjs';
import { catchError, defaultIfEmpty, filter, map, mergeMap, shareReplay, takeUntil } from 'rxjs/operators';
import { META_KEY, NgxsConfig } from '../symbols';
import { buildGraph, findFullParentPath, isObject, nameToState, propGetter, topologicalSort, getStoreMetadata } from './internals';
import { getActionTypeFromInstance, getValue, setValue } from '../utils/utils';
import { ofActionDispatched } from '../operators/of-action';
import { InternalActions } from '../actions-stream';
import { InternalDispatchedActionResults } from '../internal/dispatcher';
import { StateContextFactory } from '../internal/state-context-factory';
import { StoreValidators } from '../utils/store-validators';
import { INITIAL_STATE_TOKEN, memoize } from '@ngxs/store/internals';
/**
 * State factory class
 * @ignore
 */
export class StateFactory {
    /**
     * @param {?} _injector
     * @param {?} _config
     * @param {?} _parentFactory
     * @param {?} _actions
     * @param {?} _actionResults
     * @param {?} _stateContextFactory
     * @param {?} _initialState
     */
    constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {
        this._injector = _injector;
        this._config = _config;
        this._parentFactory = _parentFactory;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._stateContextFactory = _stateContextFactory;
        this._initialState = _initialState;
        this._actionsSubscription = null;
        this._states = [];
        this._statesByName = {};
        this._statePaths = {};
        this.getRuntimeSelectorContext = memoize((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const stateFactory = this;
            /**
             * @param {?} key
             * @return {?}
             */
            function resolveGetter(key) {
                /** @type {?} */
                const path = stateFactory.statePaths[key];
                return path ? propGetter(path.split('.'), stateFactory._config) : null;
            }
            /** @type {?} */
            const context = this._parentFactory
                ? this._parentFactory.getRuntimeSelectorContext()
                : {
                    /**
                     * @param {?} key
                     * @return {?}
                     */
                    getStateGetter(key) {
                        /** @type {?} */
                        let getter = resolveGetter(key);
                        if (getter) {
                            return getter;
                        }
                        return (/**
                         * @param {...?} args
                         * @return {?}
                         */
                        (...args) => {
                            // Late loaded getter
                            if (!getter) {
                                getter = resolveGetter(key);
                            }
                            return getter ? getter(...args) : undefined;
                        });
                    },
                    /**
                     * @param {?=} localOptions
                     * @return {?}
                     */
                    getSelectorOptions(localOptions) {
                        /** @type {?} */
                        const globalSelectorOptions = stateFactory._config.selectorOptions;
                        return Object.assign({}, globalSelectorOptions, (localOptions || {}));
                    }
                };
            return context;
        }));
    }
    /**
     * @return {?}
     */
    get states() {
        return this._parentFactory ? this._parentFactory.states : this._states;
    }
    /**
     * @return {?}
     */
    get statesByName() {
        return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;
    }
    /**
     * @private
     * @return {?}
     */
    get statePaths() {
        return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;
    }
    /**
     * @private
     * @param {?} defaults
     * @return {?}
     */
    static cloneDefaults(defaults) {
        /** @type {?} */
        let value = {};
        if (Array.isArray(defaults)) {
            value = defaults.slice();
        }
        else if (isObject(defaults)) {
            value = Object.assign({}, defaults);
        }
        else if (defaults === undefined) {
            value = {};
        }
        else {
            value = defaults;
        }
        return value;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // I'm using non-null assertion here since `_actionsSubscrition` will
        // be 100% defined. This is because `ngOnDestroy()` cannot be invoked
        // on the `StateFactory` until its initialized :) An it's initialized
        // for the first time along with the `NgxsRootModule`.
        (/** @type {?} */ (this._actionsSubscription)).unsubscribe();
    }
    /**
     * Add a new state to the global defs.
     * @param {?} stateClasses
     * @return {?}
     */
    add(stateClasses) {
        // Caretaker note: we have still left the `typeof` condition in order to avoid
        // creating a breaking change for projects that still use the View Engine.
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            StoreValidators.checkThatStateClassesHaveBeenDecorated(stateClasses);
        }
        const { newStates } = this.addToStatesMap(stateClasses);
        if (!newStates.length)
            return [];
        /** @type {?} */
        const stateGraph = buildGraph(newStates);
        /** @type {?} */
        const sortedStates = topologicalSort(stateGraph);
        /** @type {?} */
        const paths = findFullParentPath(stateGraph);
        /** @type {?} */
        const nameGraph = nameToState(newStates);
        /** @type {?} */
        const bootstrappedStores = [];
        for (const name of sortedStates) {
            /** @type {?} */
            const stateClass = nameGraph[name];
            /** @type {?} */
            const path = paths[name];
            /** @type {?} */
            const meta = (/** @type {?} */ (stateClass[META_KEY]));
            this.addRuntimeInfoToMeta(meta, path);
            /** @type {?} */
            const stateMap = {
                name,
                path,
                isInitialised: false,
                actions: meta.actions,
                instance: this._injector.get(stateClass),
                defaults: StateFactory.cloneDefaults(meta.defaults)
            };
            // ensure our store hasn't already been added
            // but don't throw since it could be lazy
            // loaded from different paths
            if (!this.hasBeenMountedAndBootstrapped(name, path)) {
                bootstrappedStores.push(stateMap);
            }
            this.states.push(stateMap);
        }
        return bootstrappedStores;
    }
    /**
     * Add a set of states to the store and return the defaults
     * @param {?} stateClasses
     * @return {?}
     */
    addAndReturnDefaults(stateClasses) {
        /** @type {?} */
        const classes = stateClasses || [];
        /** @type {?} */
        const mappedStores = this.add(classes);
        /** @type {?} */
        const defaults = mappedStores.reduce((/**
         * @param {?} result
         * @param {?} mappedStore
         * @return {?}
         */
        (result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults)), {});
        return { defaults, states: mappedStores };
    }
    /**
     * Bind the actions to the handlers
     * @return {?}
     */
    connectActionHandlers() {
        if (this._actionsSubscription !== null)
            return;
        /** @type {?} */
        const dispatched$ = new Subject();
        this._actionsSubscription = this._actions
            .pipe(filter((/**
         * @param {?} ctx
         * @return {?}
         */
        (ctx) => ctx.status === "DISPATCHED" /* Dispatched */)), mergeMap((/**
         * @param {?} ctx
         * @return {?}
         */
        ctx => {
            dispatched$.next(ctx);
            /** @type {?} */
            const action = ctx.action;
            return this.invokeActions(dispatched$, (/** @type {?} */ (action))).pipe(map((/**
             * @return {?}
             */
            () => (/** @type {?} */ ({ action, status: "SUCCESSFUL" /* Successful */ })))), defaultIfEmpty((/** @type {?} */ ({ action, status: "CANCELED" /* Canceled */ }))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of((/** @type {?} */ ({ action, status: "ERRORED" /* Errored */, error }))))));
        })))
            .subscribe((/**
         * @param {?} ctx
         * @return {?}
         */
        ctx => this._actionResults.next(ctx)));
    }
    /**
     * Invoke actions on the states.
     * @param {?} dispatched$
     * @param {?} action
     * @return {?}
     */
    invokeActions(dispatched$, action) {
        /** @type {?} */
        const type = (/** @type {?} */ (getActionTypeFromInstance(action)));
        /** @type {?} */
        const results = [];
        for (const metadata of this.states) {
            /** @type {?} */
            const actionMetas = metadata.actions[type];
            if (actionMetas) {
                for (const actionMeta of actionMetas) {
                    /** @type {?} */
                    const stateContext = this._stateContextFactory.createStateContext(metadata);
                    try {
                        /** @type {?} */
                        let result = metadata.instance[actionMeta.fn](stateContext, action);
                        if (result instanceof Promise) {
                            result = from(result);
                        }
                        if (result instanceof Observable) {
                            // If this observable has been completed w/o emitting
                            // any value then we wouldn't want to complete the whole chain
                            // of actions. Since if any observable completes then
                            // action will be canceled.
                            // For instance if any action handler would've had such statement:
                            // `handler(ctx) { return EMPTY; }`
                            // then the action will be canceled.
                            // See https://github.com/ngxs/store/issues/1568
                            result = result.pipe(mergeMap((/**
                             * @param {?} value
                             * @return {?}
                             */
                            (value) => {
                                if (value instanceof Promise) {
                                    return from(value);
                                }
                                if (value instanceof Observable) {
                                    return value;
                                }
                                return of(value);
                            })), defaultIfEmpty({}));
                            if (actionMeta.options.cancelUncompleted) {
                                // todo: ofActionDispatched should be used with action class
                                result = result.pipe(takeUntil(dispatched$.pipe(ofActionDispatched((/** @type {?} */ (action))))));
                            }
                        }
                        else {
                            result = of({}).pipe(shareReplay());
                        }
                        results.push(result);
                    }
                    catch (e) {
                        results.push(throwError(e));
                    }
                }
            }
        }
        if (!results.length) {
            results.push(of({}));
        }
        return forkJoin(results);
    }
    /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    addToStatesMap(stateClasses) {
        /** @type {?} */
        const newStates = [];
        /** @type {?} */
        const statesMap = this.statesByName;
        for (const stateClass of stateClasses) {
            /** @type {?} */
            const stateName = (/** @type {?} */ (getStoreMetadata(stateClass).name));
            // Caretaker note: we have still left the `typeof` condition in order to avoid
            // creating a breaking change for projects that still use the View Engine.
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
                StoreValidators.checkThatStateNameIsUnique(stateName, stateClass, statesMap);
            }
            /** @type {?} */
            const unmountedState = !statesMap[stateName];
            if (unmountedState) {
                newStates.push(stateClass);
                statesMap[stateName] = stateClass;
            }
        }
        return { newStates };
    }
    /**
     * @private
     * @param {?} meta
     * @param {?} path
     * @return {?}
     */
    addRuntimeInfoToMeta(meta, path) {
        this.statePaths[(/** @type {?} */ (meta.name))] = path;
        // TODO: v4 - we plan to get rid of the path property because it is non-deterministic
        // we can do this when we get rid of the incorrectly exposed getStoreMetadata
        // We will need to come up with an alternative in v4 because this is used by many plugins
        meta.path = path;
    }
    /**
     * \@description
     * the method checks if the state has already been added to the tree
     * and completed the life cycle
     * @private
     * @param {?} name
     * @param {?} path
     * @return {?}
     */
    hasBeenMountedAndBootstrapped(name, path) {
        /** @type {?} */
        const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;
        return this.statesByName[name] && valueIsBootstrappedInInitialState;
    }
}
StateFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
StateFactory.ctorParameters = () => [
    { type: Injector },
    { type: NgxsConfig },
    { type: StateFactory, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: InternalActions },
    { type: InternalDispatchedActionResults },
    { type: StateContextFactory },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [INITIAL_STATE_TOKEN,] }] }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actionsSubscription;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._states;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._statesByName;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._statePaths;
    /** @type {?} */
    StateFactory.prototype.getRuntimeSelectorContext;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._injector;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._config;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._parentFactory;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actions;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actionResults;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._stateContextFactory;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._initialState;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3hzL3N0b3JlLyIsInNvdXJjZXMiOlsic3JjL2ludGVybmFsL3N0YXRlLWZhY3RvcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFhLE1BQU0sZUFBZSxDQUFDO0FBQzVGLE9BQU8sRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxFQUFFLEVBQUUsVUFBVSxFQUFnQixPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDekYsT0FBTyxFQUNMLFVBQVUsRUFDVixjQUFjLEVBQ2QsTUFBTSxFQUNOLEdBQUcsRUFDSCxRQUFRLEVBQ1IsV0FBVyxFQUNYLFNBQVMsRUFDVixNQUFNLGdCQUFnQixDQUFDO0FBRXhCLE9BQU8sRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ2xELE9BQU8sRUFDTCxVQUFVLEVBQ1Ysa0JBQWtCLEVBQ2xCLFFBQVEsRUFHUixXQUFXLEVBQ1gsVUFBVSxFQUtWLGVBQWUsRUFHZixnQkFBZ0IsRUFDakIsTUFBTSxhQUFhLENBQUM7QUFDckIsT0FBTyxFQUFFLHlCQUF5QixFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMvRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUM1RCxPQUFPLEVBQStCLGVBQWUsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ2pGLE9BQU8sRUFBRSwrQkFBK0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsbUJBQW1CLEVBQWlCLE9BQU8sRUFB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QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdG9yLCBPcHRpb25hbCwgU2tpcFNlbGYsIEluamVjdCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBmb3JrSm9pbiwgZnJvbSwgT2JzZXJ2YWJsZSwgb2YsIHRocm93RXJyb3IsIFN1YnNjcmlwdGlvbiwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgY2F0Y2hFcnJvcixcbiAgZGVmYXVsdElmRW1wdHksXG4gIGZpbHRlcixcbiAgbWFwLFxuICBtZXJnZU1hcCxcbiAgc2hhcmVSZXBsYXksXG4gIHRha2VVbnRpbFxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IE1FVEFfS0VZLCBOZ3hzQ29uZmlnIH0gZnJvbSAnLi4vc3ltYm9scyc7XG5pbXBvcnQge1xuICBidWlsZEdyYXBoLFxuICBmaW5kRnVsbFBhcmVudFBhdGgsXG4gIGlzT2JqZWN0LFxuICBNYXBwZWRTdG9yZSxcbiAgTWV0YURhdGFNb2RlbCxcbiAgbmFtZVRvU3RhdGUsXG4gIHByb3BHZXR0ZXIsXG4gIFN0YXRlQ2xhc3NJbnRlcm5hbCxcbiAgU3RhdGVLZXlHcmFwaCxcbiAgU3RhdGVzQW5kRGVmYXVsdHMsXG4gIFN0YXRlc0J5TmFtZSxcbiAgdG9wb2xvZ2ljYWxTb3J0LFxuICBSdW50aW1lU2VsZWN0b3JDb250ZXh0LFxuICBTaGFyZWRTZWxlY3Rvck9wdGlvbnMsXG4gIGdldFN0b3JlTWV0YWRhdGFcbn0gZnJvbSAnLi9pbnRlcm5hbHMnO1xuaW1wb3J0IHsgZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZSwgZ2V0VmFsdWUsIHNldFZhbHVlIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IHsgb2ZBY3Rpb25EaXNwYXRjaGVkIH0gZnJvbSAnLi4vb3BlcmF0b3JzL29mLWFjdGlvbic7XG5pbXBvcnQgeyBBY3Rpb25Db250ZXh0LCBBY3Rpb25TdGF0dXMsIEludGVybmFsQWN0aW9ucyB9IGZyb20gJy4uL2FjdGlvbnMtc3RyZWFtJztcbmltcG9ydCB7IEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMgfSBmcm9tICcuLi9pbnRlcm5hbC9kaXNwYXRjaGVyJztcbmltcG9ydCB7IFN0YXRlQ29udGV4dEZhY3RvcnkgfSBmcm9tICcuLi9pbnRlcm5hbC9zdGF0ZS1jb250ZXh0LWZhY3RvcnknO1xuaW1wb3J0IHsgU3RvcmVWYWxpZGF0b3JzIH0gZnJvbSAnLi4vdXRpbHMvc3RvcmUtdmFsaWRhdG9ycyc7XG5pbXBvcnQgeyBJTklUSUFMX1NUQVRFX1RPS0VOLCBQbGFpbk9iamVjdE9mLCBtZW1vaXplIH0gZnJvbSAnQG5neHMvc3RvcmUvaW50ZXJuYWxzJztcblxuLyoqXG4gKiBTdGF0ZSBmYWN0b3J5IGNsYXNzXG4gKiBAaWdub3JlXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTdGF0ZUZhY3RvcnkgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIF9hY3Rpb25zU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9pbmplY3RvcjogSW5qZWN0b3IsXG4gICAgcHJpdmF0ZSBfY29uZmlnOiBOZ3hzQ29uZmlnLFxuICAgIEBPcHRpb25hbCgpXG4gICAgQFNraXBTZWxmKClcbiAgICBwcml2YXRlIF9wYXJlbnRGYWN0b3J5OiBTdGF0ZUZhY3RvcnksXG4gICAgcHJpdmF0ZSBfYWN0aW9uczogSW50ZXJuYWxBY3Rpb25zLFxuICAgIHByaXZhdGUgX2FjdGlvblJlc3VsdHM6IEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMsXG4gICAgcHJpdmF0ZSBfc3RhdGVDb250ZXh0RmFjdG9yeTogU3RhdGVDb250ZXh0RmFjdG9yeSxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoSU5JVElBTF9TVEFURV9UT0tFTilcbiAgICBwcml2YXRlIF9pbml0aWFsU3RhdGU6IGFueVxuICApIHt9XG5cbiAgcHJpdmF0ZSBfc3RhdGVzOiBNYXBwZWRTdG9yZVtdID0gW107XG5cbiAgZ2V0IHN0YXRlcygpOiBNYXBwZWRTdG9yZVtdIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50RmFjdG9yeSA/IHRoaXMuX3BhcmVudEZhY3Rvcnkuc3RhdGVzIDogdGhpcy5fc3RhdGVzO1xuICB9XG5cbiAgcHJpdmF0ZSBfc3RhdGVzQnlOYW1lOiBTdGF0ZXNCeU5hbWUgPSB7fTtcblxuICBnZXQgc3RhdGVzQnlOYW1lKCk6IFN0YXRlc0J5TmFtZSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEZhY3RvcnkgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LnN0YXRlc0J5TmFtZSA6IHRoaXMuX3N0YXRlc0J5TmFtZTtcbiAgfVxuXG4gIHByaXZhdGUgX3N0YXRlUGF0aHM6IFBsYWluT2JqZWN0T2Y8c3RyaW5nPiA9IHt9O1xuXG4gIHByaXZhdGUgZ2V0IHN0YXRlUGF0aHMoKTogUGxhaW5PYmplY3RPZjxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50RmFjdG9yeSA/IHRoaXMuX3BhcmVudEZhY3Rvcnkuc3RhdGVQYXRocyA6IHRoaXMuX3N0YXRlUGF0aHM7XG4gIH1cblxuICBnZXRSdW50aW1lU2VsZWN0b3JDb250ZXh0ID0gbWVtb2l6ZSgoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGVGYWN0b3J5ID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIHJlc29sdmVHZXR0ZXIoa2V5OiBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IHBhdGggPSBzdGF0ZUZhY3Rvcnkuc3RhdGVQYXRoc1trZXldO1xuICAgICAgcmV0dXJuIHBhdGggPyBwcm9wR2V0dGVyKHBhdGguc3BsaXQoJy4nKSwgc3RhdGVGYWN0b3J5Ll9jb25maWcpIDogbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZXh0OiBSdW50aW1lU2VsZWN0b3JDb250ZXh0ID0gdGhpcy5fcGFyZW50RmFjdG9yeVxuICAgICAgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LmdldFJ1bnRpbWVTZWxlY3RvckNvbnRleHQoKVxuICAgICAgOiB7XG4gICAgICAgICAgZ2V0U3RhdGVHZXR0ZXIoa2V5OiBzdHJpbmcpIHtcbiAgICAgICAgICAgIGxldCBnZXR0ZXIgPSByZXNvbHZlR2V0dGVyKGtleSk7XG4gICAgICAgICAgICBpZiAoZ2V0dGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXR0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgLy8gTGF0ZSBsb2FkZWQgZ2V0dGVyXG4gICAgICAgICAgICAgIGlmICghZ2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgZ2V0dGVyID0gcmVzb2x2ZUdldHRlcihrZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIoLi4uYXJncykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0U2VsZWN0b3JPcHRpb25zKGxvY2FsT3B0aW9ucz86IFNoYXJlZFNlbGVjdG9yT3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZ2xvYmFsU2VsZWN0b3JPcHRpb25zID0gc3RhdGVGYWN0b3J5Ll9jb25maWcuc2VsZWN0b3JPcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uZ2xvYmFsU2VsZWN0b3JPcHRpb25zLFxuICAgICAgICAgICAgICAuLi4obG9jYWxPcHRpb25zIHx8IHt9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH0pO1xuXG4gIHByaXZhdGUgc3RhdGljIGNsb25lRGVmYXVsdHMoZGVmYXVsdHM6IGFueSk6IGFueSB7XG4gICAgbGV0IHZhbHVlID0ge307XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZhdWx0cykpIHtcbiAgICAgIHZhbHVlID0gZGVmYXVsdHMuc2xpY2UoKTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGRlZmF1bHRzKSkge1xuICAgICAgdmFsdWUgPSB7IC4uLmRlZmF1bHRzIH07XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWx1ZSA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGRlZmF1bHRzO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIC8vIEknbSB1c2luZyBub24tbnVsbCBhc3NlcnRpb24gaGVyZSBzaW5jZSBgX2FjdGlvbnNTdWJzY3JpdGlvbmAgd2lsbFxuICAgIC8vIGJlIDEwMCUgZGVmaW5lZC4gVGhpcyBpcyBiZWNhdXNlIGBuZ09uRGVzdHJveSgpYCBjYW5ub3QgYmUgaW52b2tlZFxuICAgIC8vIG9uIHRoZSBgU3RhdGVGYWN0b3J5YCB1bnRpbCBpdHMgaW5pdGlhbGl6ZWQgOikgQW4gaXQncyBpbml0aWFsaXplZFxuICAgIC8vIGZvciB0aGUgZmlyc3QgdGltZSBhbG9uZyB3aXRoIHRoZSBgTmd4c1Jvb3RNb2R1bGVgLlxuICAgIHRoaXMuX2FjdGlvbnNTdWJzY3JpcHRpb24hLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IHN0YXRlIHRvIHRoZSBnbG9iYWwgZGVmcy5cbiAgICovXG4gIGFkZChzdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdKTogTWFwcGVkU3RvcmVbXSB7XG4gICAgLy8gQ2FyZXRha2VyIG5vdGU6IHdlIGhhdmUgc3RpbGwgbGVmdCB0aGUgYHR5cGVvZmAgY29uZGl0aW9uIGluIG9yZGVyIHRvIGF2b2lkXG4gICAgLy8gY3JlYXRpbmcgYSBicmVha2luZyBjaGFuZ2UgZm9yIHByb2plY3RzIHRoYXQgc3RpbGwgdXNlIHRoZSBWaWV3IEVuZ2luZS5cbiAgICBpZiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSB7XG4gICAgICBTdG9yZVZhbGlkYXRvcnMuY2hlY2tUaGF0U3RhdGVDbGFzc2VzSGF2ZUJlZW5EZWNvcmF0ZWQoc3RhdGVDbGFzc2VzKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IG5ld1N0YXRlcyB9ID0gdGhpcy5hZGRUb1N0YXRlc01hcChzdGF0ZUNsYXNzZXMpO1xuICAgIGlmICghbmV3U3RhdGVzLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgY29uc3Qgc3RhdGVHcmFwaDogU3RhdGVLZXlHcmFwaCA9IGJ1aWxkR3JhcGgobmV3U3RhdGVzKTtcbiAgICBjb25zdCBzb3J0ZWRTdGF0ZXM6IHN0cmluZ1tdID0gdG9wb2xvZ2ljYWxTb3J0KHN0YXRlR3JhcGgpO1xuICAgIGNvbnN0IHBhdGhzOiBQbGFpbk9iamVjdE9mPHN0cmluZz4gPSBmaW5kRnVsbFBhcmVudFBhdGgoc3RhdGVHcmFwaCk7XG4gICAgY29uc3QgbmFtZUdyYXBoOiBQbGFpbk9iamVjdE9mPFN0YXRlQ2xhc3NJbnRlcm5hbD4gPSBuYW1lVG9TdGF0ZShuZXdTdGF0ZXMpO1xuICAgIGNvbnN0IGJvb3RzdHJhcHBlZFN0b3JlczogTWFwcGVkU3RvcmVbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHNvcnRlZFN0YXRlcykge1xuICAgICAgY29uc3Qgc3RhdGVDbGFzczogU3RhdGVDbGFzc0ludGVybmFsID0gbmFtZUdyYXBoW25hbWVdO1xuICAgICAgY29uc3QgcGF0aDogc3RyaW5nID0gcGF0aHNbbmFtZV07XG4gICAgICBjb25zdCBtZXRhOiBNZXRhRGF0YU1vZGVsID0gc3RhdGVDbGFzc1tNRVRBX0tFWV0hO1xuXG4gICAgICB0aGlzLmFkZFJ1bnRpbWVJbmZvVG9NZXRhKG1ldGEsIHBhdGgpO1xuXG4gICAgICBjb25zdCBzdGF0ZU1hcDogTWFwcGVkU3RvcmUgPSB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIGlzSW5pdGlhbGlzZWQ6IGZhbHNlLFxuICAgICAgICBhY3Rpb25zOiBtZXRhLmFjdGlvbnMsXG4gICAgICAgIGluc3RhbmNlOiB0aGlzLl9pbmplY3Rvci5nZXQoc3RhdGVDbGFzcyksXG4gICAgICAgIGRlZmF1bHRzOiBTdGF0ZUZhY3RvcnkuY2xvbmVEZWZhdWx0cyhtZXRhLmRlZmF1bHRzKVxuICAgICAgfTtcblxuICAgICAgLy8gZW5zdXJlIG91ciBzdG9yZSBoYXNuJ3QgYWxyZWFkeSBiZWVuIGFkZGVkXG4gICAgICAvLyBidXQgZG9uJ3QgdGhyb3cgc2luY2UgaXQgY291bGQgYmUgbGF6eVxuICAgICAgLy8gbG9hZGVkIGZyb20gZGlmZmVyZW50IHBhdGhzXG4gICAgICBpZiAoIXRoaXMuaGFzQmVlbk1vdW50ZWRBbmRCb290c3RyYXBwZWQobmFtZSwgcGF0aCkpIHtcbiAgICAgICAgYm9vdHN0cmFwcGVkU3RvcmVzLnB1c2goc3RhdGVNYXApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlcy5wdXNoKHN0YXRlTWFwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYm9vdHN0cmFwcGVkU3RvcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHNldCBvZiBzdGF0ZXMgdG8gdGhlIHN0b3JlIGFuZCByZXR1cm4gdGhlIGRlZmF1bHRzXG4gICAqL1xuICBhZGRBbmRSZXR1cm5EZWZhdWx0cyhzdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdKTogU3RhdGVzQW5kRGVmYXVsdHMge1xuICAgIGNvbnN0IGNsYXNzZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdID0gc3RhdGVDbGFzc2VzIHx8IFtdO1xuXG4gICAgY29uc3QgbWFwcGVkU3RvcmVzOiBNYXBwZWRTdG9yZVtdID0gdGhpcy5hZGQoY2xhc3Nlcyk7XG4gICAgY29uc3QgZGVmYXVsdHMgPSBtYXBwZWRTdG9yZXMucmVkdWNlKFxuICAgICAgKHJlc3VsdDogYW55LCBtYXBwZWRTdG9yZTogTWFwcGVkU3RvcmUpID0+XG4gICAgICAgIHNldFZhbHVlKHJlc3VsdCwgbWFwcGVkU3RvcmUucGF0aCwgbWFwcGVkU3RvcmUuZGVmYXVsdHMpLFxuICAgICAge31cbiAgICApO1xuICAgIHJldHVybiB7IGRlZmF1bHRzLCBzdGF0ZXM6IG1hcHBlZFN0b3JlcyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEJpbmQgdGhlIGFjdGlvbnMgdG8gdGhlIGhhbmRsZXJzXG4gICAqL1xuICBjb25uZWN0QWN0aW9uSGFuZGxlcnMoKSB7XG4gICAgaWYgKHRoaXMuX2FjdGlvbnNTdWJzY3JpcHRpb24gIT09IG51bGwpIHJldHVybjtcbiAgICBjb25zdCBkaXNwYXRjaGVkJCA9IG5ldyBTdWJqZWN0PEFjdGlvbkNvbnRleHQ+KCk7XG4gICAgdGhpcy5fYWN0aW9uc1N1YnNjcmlwdGlvbiA9IHRoaXMuX2FjdGlvbnNcbiAgICAgIC5waXBlKFxuICAgICAgICBmaWx0ZXIoKGN0eDogQWN0aW9uQ29udGV4dCkgPT4gY3R4LnN0YXR1cyA9PT0gQWN0aW9uU3RhdHVzLkRpc3BhdGNoZWQpLFxuICAgICAgICBtZXJnZU1hcChjdHggPT4ge1xuICAgICAgICAgIGRpc3BhdGNoZWQkLm5leHQoY3R4KTtcbiAgICAgICAgICBjb25zdCBhY3Rpb24gPSBjdHguYWN0aW9uO1xuICAgICAgICAgIHJldHVybiB0aGlzLmludm9rZUFjdGlvbnMoZGlzcGF0Y2hlZCQsIGFjdGlvbiEpLnBpcGUoXG4gICAgICAgICAgICBtYXAoKCkgPT4gPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLlN1Y2Nlc3NmdWwgfSksXG4gICAgICAgICAgICBkZWZhdWx0SWZFbXB0eSg8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuQ2FuY2VsZWQgfSksXG4gICAgICAgICAgICBjYXRjaEVycm9yKGVycm9yID0+XG4gICAgICAgICAgICAgIG9mKDxBY3Rpb25Db250ZXh0PnsgYWN0aW9uLCBzdGF0dXM6IEFjdGlvblN0YXR1cy5FcnJvcmVkLCBlcnJvciB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKGN0eCA9PiB0aGlzLl9hY3Rpb25SZXN1bHRzLm5leHQoY3R4KSk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlIGFjdGlvbnMgb24gdGhlIHN0YXRlcy5cbiAgICovXG4gIGludm9rZUFjdGlvbnMoZGlzcGF0Y2hlZCQ6IE9ic2VydmFibGU8QWN0aW9uQ29udGV4dD4sIGFjdGlvbjogYW55KSB7XG4gICAgY29uc3QgdHlwZSA9IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UoYWN0aW9uKSE7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBtZXRhZGF0YSBvZiB0aGlzLnN0YXRlcykge1xuICAgICAgY29uc3QgYWN0aW9uTWV0YXMgPSBtZXRhZGF0YS5hY3Rpb25zW3R5cGVdO1xuXG4gICAgICBpZiAoYWN0aW9uTWV0YXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBhY3Rpb25NZXRhIG9mIGFjdGlvbk1ldGFzKSB7XG4gICAgICAgICAgY29uc3Qgc3RhdGVDb250ZXh0ID0gdGhpcy5fc3RhdGVDb250ZXh0RmFjdG9yeS5jcmVhdGVTdGF0ZUNvbnRleHQobWV0YWRhdGEpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWV0YWRhdGEuaW5zdGFuY2VbYWN0aW9uTWV0YS5mbl0oc3RhdGVDb250ZXh0LCBhY3Rpb24pO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBmcm9tKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoaXMgb2JzZXJ2YWJsZSBoYXMgYmVlbiBjb21wbGV0ZWQgdy9vIGVtaXR0aW5nXG4gICAgICAgICAgICAgIC8vIGFueSB2YWx1ZSB0aGVuIHdlIHdvdWxkbid0IHdhbnQgdG8gY29tcGxldGUgdGhlIHdob2xlIGNoYWluXG4gICAgICAgICAgICAgIC8vIG9mIGFjdGlvbnMuIFNpbmNlIGlmIGFueSBvYnNlcnZhYmxlIGNvbXBsZXRlcyB0aGVuXG4gICAgICAgICAgICAgIC8vIGFjdGlvbiB3aWxsIGJlIGNhbmNlbGVkLlxuICAgICAgICAgICAgICAvLyBGb3IgaW5zdGFuY2UgaWYgYW55IGFjdGlvbiBoYW5kbGVyIHdvdWxkJ3ZlIGhhZCBzdWNoIHN0YXRlbWVudDpcbiAgICAgICAgICAgICAgLy8gYGhhbmRsZXIoY3R4KSB7IHJldHVybiBFTVBUWTsgfWBcbiAgICAgICAgICAgICAgLy8gdGhlbiB0aGUgYWN0aW9uIHdpbGwgYmUgY2FuY2VsZWQuXG4gICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbmd4cy9zdG9yZS9pc3N1ZXMvMTU2OFxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShcbiAgICAgICAgICAgICAgICBtZXJnZU1hcCgodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJvbSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBvZih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZGVmYXVsdElmRW1wdHkoe30pXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgaWYgKGFjdGlvbk1ldGEub3B0aW9ucy5jYW5jZWxVbmNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgIC8vIHRvZG86IG9mQWN0aW9uRGlzcGF0Y2hlZCBzaG91bGQgYmUgdXNlZCB3aXRoIGFjdGlvbiBjbGFzc1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKFxuICAgICAgICAgICAgICAgICAgdGFrZVVudGlsKGRpc3BhdGNoZWQkLnBpcGUob2ZBY3Rpb25EaXNwYXRjaGVkKGFjdGlvbiBhcyBhbnkpKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQgPSBvZih7fSkucGlwZShzaGFyZVJlcGxheSgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRocm93RXJyb3IoZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdHMucHVzaChvZih7fSkpO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JrSm9pbihyZXN1bHRzKTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkVG9TdGF0ZXNNYXAoXG4gICAgc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXVxuICApOiB7IG5ld1N0YXRlczogU3RhdGVDbGFzc0ludGVybmFsW10gfSB7XG4gICAgY29uc3QgbmV3U3RhdGVzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSA9IFtdO1xuICAgIGNvbnN0IHN0YXRlc01hcDogU3RhdGVzQnlOYW1lID0gdGhpcy5zdGF0ZXNCeU5hbWU7XG5cbiAgICBmb3IgKGNvbnN0IHN0YXRlQ2xhc3Mgb2Ygc3RhdGVDbGFzc2VzKSB7XG4gICAgICBjb25zdCBzdGF0ZU5hbWUgPSBnZXRTdG9yZU1ldGFkYXRhKHN0YXRlQ2xhc3MpLm5hbWUhO1xuICAgICAgLy8gQ2FyZXRha2VyIG5vdGU6IHdlIGhhdmUgc3RpbGwgbGVmdCB0aGUgYHR5cGVvZmAgY29uZGl0aW9uIGluIG9yZGVyIHRvIGF2b2lkXG4gICAgICAvLyBjcmVhdGluZyBhIGJyZWFraW5nIGNoYW5nZSBmb3IgcHJvamVjdHMgdGhhdCBzdGlsbCB1c2UgdGhlIFZpZXcgRW5naW5lLlxuICAgICAgaWYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkge1xuICAgICAgICBTdG9yZVZhbGlkYXRvcnMuY2hlY2tUaGF0U3RhdGVOYW1lSXNVbmlxdWUoc3RhdGVOYW1lLCBzdGF0ZUNsYXNzLCBzdGF0ZXNNYXApO1xuICAgICAgfVxuICAgICAgY29uc3QgdW5tb3VudGVkU3RhdGUgPSAhc3RhdGVzTWFwW3N0YXRlTmFtZV07XG4gICAgICBpZiAodW5tb3VudGVkU3RhdGUpIHtcbiAgICAgICAgbmV3U3RhdGVzLnB1c2goc3RhdGVDbGFzcyk7XG4gICAgICAgIHN0YXRlc01hcFtzdGF0ZU5hbWVdID0gc3RhdGVDbGFzcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBuZXdTdGF0ZXMgfTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkUnVudGltZUluZm9Ub01ldGEobWV0YTogTWV0YURhdGFNb2RlbCwgcGF0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5zdGF0ZVBhdGhzW21ldGEubmFtZSFdID0gcGF0aDtcbiAgICAvLyBUT0RPOiB2NCAtIHdlIHBsYW4gdG8gZ2V0IHJpZCBvZiB0aGUgcGF0aCBwcm9wZXJ0eSBiZWNhdXNlIGl0IGlzIG5vbi1kZXRlcm1pbmlzdGljXG4gICAgLy8gd2UgY2FuIGRvIHRoaXMgd2hlbiB3ZSBnZXQgcmlkIG9mIHRoZSBpbmNvcnJlY3RseSBleHBvc2VkIGdldFN0b3JlTWV0YWRhdGFcbiAgICAvLyBXZSB3aWxsIG5lZWQgdG8gY29tZSB1cCB3aXRoIGFuIGFsdGVybmF0aXZlIGluIHY0IGJlY2F1c2UgdGhpcyBpcyB1c2VkIGJ5IG1hbnkgcGx1Z2luc1xuICAgIG1ldGEucGF0aCA9IHBhdGg7XG4gIH1cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIHRoZSBtZXRob2QgY2hlY2tzIGlmIHRoZSBzdGF0ZSBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIHRoZSB0cmVlXG4gICAqIGFuZCBjb21wbGV0ZWQgdGhlIGxpZmUgY3ljbGVcbiAgICogQHBhcmFtIG5hbWVcbiAgICogQHBhcmFtIHBhdGhcbiAgICovXG4gIHByaXZhdGUgaGFzQmVlbk1vdW50ZWRBbmRCb290c3RyYXBwZWQobmFtZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCB2YWx1ZUlzQm9vdHN0cmFwcGVkSW5Jbml0aWFsU3RhdGU6IGJvb2xlYW4gPVxuICAgICAgZ2V0VmFsdWUodGhpcy5faW5pdGlhbFN0YXRlLCBwYXRoKSAhPT0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0aGlzLnN0YXRlc0J5TmFtZVtuYW1lXSAmJiB2YWx1ZUlzQm9vdHN0cmFwcGVkSW5Jbml0aWFsU3RhdGU7XG4gIH1cbn1cbiJdfQ==