/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { INJECTOR, ɵɵdirectiveInject, ɵglobal } from '@angular/core';
import { ReplaySubject } from 'rxjs';
// Angular doesn't export `NG_FACTORY_DEF`.
/** @type {?} */
const NG_FACTORY_DEF = 'ɵfac';
// A `Symbol` which is used to save the `Injector` onto the class instance.
/** @type {?} */
const InjectorInstance = Symbol('InjectorInstance');
// A `Symbol` which is used to determine if factory has been decorated previously or not.
/** @type {?} */
const FactoryHasBeenDecorated = Symbol('FactoryHasBeenDecorated');
// A `Symbol` which is used to save the notifier on the class instance. The `InjectorInstance` cannot
// be retrieved within the `constructor` since it's set after the `factory()` is called.
/** @type {?} */
const InjectorNotifier = Symbol('InjectorNotifier');
/**
 * @record
 */
function PrototypeWithInjectorNotifier() { }
if (false) {
    /* Skipping unnamed member:
    [InjectorNotifier]?: ReplaySubject<boolean>;*/
}
/**
 * @param {?} target
 * @return {?}
 */
export function ensureInjectorNotifierIsCaptured(target) {
    if (target[InjectorNotifier]) {
        return (/** @type {?} */ (target[InjectorNotifier]));
    }
    else {
        /** @type {?} */
        const injectorNotifier$ = new ReplaySubject(1);
        Object.defineProperty(target, InjectorNotifier, {
            get: (/**
             * @return {?}
             */
            () => injectorNotifier$)
        });
        return injectorNotifier$;
    }
}
// eslint-disable-next-line @typescript-eslint/ban-types
/**
 * @param {?} target
 * @return {?}
 */
export function ensureLocalInjectorCaptured(target) {
    if (FactoryHasBeenDecorated in target.constructor.prototype) {
        return;
    }
    /** @type {?} */
    const constructor = target.constructor;
    // Means we're in AOT mode.
    if (typeof constructor[NG_FACTORY_DEF] === 'function') {
        decorateFactory(constructor);
    }
    else if (ngDevMode) {
        // We're running in JIT mode and that means we're not able to get the compiled definition
        // on the class inside the property decorator during the current message loop tick. We have
        // to wait for the next message loop tick. Note that this is safe since this Promise will be
        // resolved even before the `APP_INITIALIZER` is resolved.
        // The below code also will be executed only in development mode, since it's never recommended
        // to use the JIT compiler in production mode (by setting "aot: false").
        decorateFactoryLater(constructor);
    }
    target.constructor.prototype[FactoryHasBeenDecorated] = true;
}
/**
 * @template T
 * @param {?} instance
 * @param {?} token
 * @return {?}
 */
export function localInject(instance, token) {
    /** @type {?} */
    const injector = instance[InjectorInstance];
    return injector ? injector.get(token) : null;
}
/**
 * @param {?} constructor
 * @return {?}
 */
function decorateFactory(constructor) {
    /** @type {?} */
    const factory = constructor[NG_FACTORY_DEF];
    if (typeof factory !== 'function') {
        return;
    }
    // Let's try to get any definition.
    // Caretaker note: this will be compatible only with Angular 9+, since Angular 9 is the first
    // Ivy-stable version. Previously definition properties were named differently (e.g. `ngComponentDef`).
    /** @type {?} */
    const def = constructor.ɵprov || constructor.ɵpipe || constructor.ɵcmp || constructor.ɵdir;
    /** @type {?} */
    const decoratedFactory = (/**
     * @return {?}
     */
    () => {
        /** @type {?} */
        const instance = factory();
        // Caretaker note: `inject()` won't work here.
        // We can use the `directiveInject` only during the component
        // construction, since Angular captures the currently active injector.
        // We're not able to use this function inside the getter (when the `selectorId` property is
        // requested for the first time), since the currently active injector will be null.
        instance[InjectorInstance] = ɵɵdirectiveInject(
        // We're using `INJECTOR` token except of the `Injector` class since the compiler
        // throws: `Cannot assign an abstract constructor type to a non-abstract constructor type.`.
        // Caretaker note: that this is the same way of getting the injector.
        INJECTOR);
        // Caretaker note: the notifier will be available only if consumers call the `ensureInjectorNotifierIsCaptured()`.
        /** @type {?} */
        const injectorNotifier$ = instance[InjectorNotifier];
        if (injectorNotifier$) {
            injectorNotifier$.next(true);
            injectorNotifier$.complete();
        }
        return instance;
    });
    // If we've found any definition then it's enough to override the `def.factory` since Angular
    // code uses the `def.factory` and then fallbacks to `ɵfac`.
    if (def) {
        def.factory = decoratedFactory;
    }
    // `@NgModule()` doesn't doesn't have definition factory, also providers have definitions but Angular
    // still uses the `ɵfac`.
    Object.defineProperty(constructor, NG_FACTORY_DEF, {
        get: (/**
         * @return {?}
         */
        () => decoratedFactory)
    });
}
/**
 * @param {?} constructor
 * @return {?}
 */
function decorateFactoryLater(constructor) {
    // This function actually will be tree-shaken away when building for production since it's guarded with `ngDevMode`.
    // We're having the `try-catch` here because of the `SyncTestZoneSpec`, which throws
    // an error when micro or macrotask is used within a synchronous test. E.g. `Cannot call
    // Promise.then from within a sync test`.
    try {
        Promise.resolve().then((/**
         * @return {?}
         */
        () => {
            decorateFactory(constructor);
        }));
    }
    catch (_a) {
        // This is kind of a "hack", but we try to be backwards-compatible,
        // tho this `catch` block will only be executed when tests are run with Jasmine or Jest.
        ɵglobal.process &&
            ɵglobal.process.nextTick &&
            ɵglobal.process.nextTick((/**
             * @return {?}
             */
            () => {
                decorateFactory(constructor);
            }));
    }
}
/**
 * @record
 */
function Definition() { }
if (false) {
    /** @type {?} */
    Definition.prototype.factory;
}
/**
 * @record
 */
function ConstructorWithDefinitionAndFactory() { }
if (false) {
    /** @type {?|undefined} */
    ConstructorWithDefinitionAndFactory.prototype.ɵprov;
    /** @type {?|undefined} */
    ConstructorWithDefinitionAndFactory.prototype.ɵpipe;
    /** @type {?|undefined} */
    ConstructorWithDefinitionAndFactory.prototype.ɵcmp;
    /** @type {?|undefined} */
    ConstructorWithDefinitionAndFactory.prototype.ɵdir;
    /* Skipping unnamed member:
    [NG_FACTORY_DEF]?: Factory;*/
}
/**
 * @record
 */
function PrivateInstance() { }
if (false) {
    /* Skipping unnamed member:
    [InjectorInstance]?: Injector;*/
    /* Skipping unnamed member:
    [InjectorNotifier]?: ReplaySubject<boolean>;*/
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjb3JhdG9yLWluamVjdG9yLWFkYXB0ZXIuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4cy9zdG9yZS9pbnRlcm5hbHMvIiwic291cmNlcyI6WyJkZWNvcmF0b3ItaW5qZWN0b3ItYWRhcHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUdMLFFBQVEsRUFFUixpQkFBaUIsRUFDakIsT0FBTyxFQUNSLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxNQUFNLENBQUM7OztNQU8vQixjQUFjLEdBQUcsTUFBTTs7O01BR3ZCLGdCQUFnQixHQUFrQixNQUFNLENBQUMsa0JBQWtCLENBQUM7OztNQUc1RCx1QkFBdUIsR0FBa0IsTUFBTSxDQUFDLHlCQUF5QixDQUFDOzs7O01BSTFFLGdCQUFnQixHQUFrQixNQUFNLENBQUMsa0JBQWtCLENBQUM7Ozs7QUFFbEUsNENBRUM7Ozs7Ozs7OztBQUVELE1BQU0sVUFBVSxnQ0FBZ0MsQ0FDOUMsTUFBdUQ7SUFFdkQsSUFBSSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtRQUM1QixPQUFPLG1CQUFBLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFDLENBQUM7S0FDbEM7U0FBTTs7Y0FDQyxpQkFBaUIsR0FBRyxJQUFJLGFBQWEsQ0FBVSxDQUFDLENBQUM7UUFDdkQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLEVBQUU7WUFDOUMsR0FBRzs7O1lBQUUsR0FBRyxFQUFFLENBQUMsaUJBQWlCLENBQUE7U0FDN0IsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxpQkFBaUIsQ0FBQztLQUMxQjtBQUNILENBQUM7Ozs7OztBQUdELE1BQU0sVUFBVSwyQkFBMkIsQ0FBQyxNQUFjO0lBQ3hELElBQUksdUJBQXVCLElBQUksTUFBTSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUU7UUFDM0QsT0FBTztLQUNSOztVQUVLLFdBQVcsR0FBd0MsTUFBTSxDQUFD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VUM7OztJQVJDLG9EQUFtQjs7SUFFbkIsb0RBQW1COztJQUVuQixtREFBa0I7O0lBRWxCLG1EQUFrQjs7Ozs7OztBQUlwQiw4QkFHQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEluamVjdGlvblRva2VuLFxuICBJbmplY3RvcixcbiAgSU5KRUNUT1IsXG4gIFR5cGUsXG4gIMm1ybVkaXJlY3RpdmVJbmplY3QsXG4gIMm1Z2xvYmFsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVwbGF5U3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG4vLyBXaWxsIGJlIHByb3ZpZGVkIHRocm91Z2ggVGVyc2VyIGdsb2JhbCBkZWZpbml0aW9ucyBieSBBbmd1bGFyIENMSVxuLy8gZHVyaW5nIHRoZSBwcm9kdWN0aW9uIGJ1aWxkLiBUaGlzIGlzIGhvdyBBbmd1bGFyIGRvZXMgdHJlZS1zaGFraW5nIGludGVybmFsbHkuXG5kZWNsYXJlIGNvbnN0IG5nRGV2TW9kZTogYm9vbGVhbjtcblxuLy8gQW5ndWxhciBkb2Vzbid0IGV4cG9ydCBgTkdfRkFDVE9SWV9ERUZgLlxuY29uc3QgTkdfRkFDVE9SWV9ERUYgPSAnybVmYWMnO1xuXG4vLyBBIGBTeW1ib2xgIHdoaWNoIGlzIHVzZWQgdG8gc2F2ZSB0aGUgYEluamVjdG9yYCBvbnRvIHRoZSBjbGFzcyBpbnN0YW5jZS5cbmNvbnN0IEluamVjdG9ySW5zdGFuY2U6IHVuaXF1ZSBzeW1ib2wgPSBTeW1ib2woJ0luamVjdG9ySW5zdGFuY2UnKTtcblxuLy8gQSBgU3ltYm9sYCB3aGljaCBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBmYWN0b3J5IGhhcyBiZWVuIGRlY29yYXRlZCBwcmV2aW91c2x5IG9yIG5vdC5cbmNvbnN0IEZhY3RvcnlIYXNCZWVuRGVjb3JhdGVkOiB1bmlxdWUgc3ltYm9sID0gU3ltYm9sKCdGYWN0b3J5SGFzQmVlbkRlY29yYXRlZCcpO1xuXG4vLyBBIGBTeW1ib2xgIHdoaWNoIGlzIHVzZWQgdG8gc2F2ZSB0aGUgbm90aWZpZXIgb24gdGhlIGNsYXNzIGluc3RhbmNlLiBUaGUgYEluamVjdG9ySW5zdGFuY2VgIGNhbm5vdFxuLy8gYmUgcmV0cmlldmVkIHdpdGhpbiB0aGUgYGNvbnN0cnVjdG9yYCBzaW5jZSBpdCdzIHNldCBhZnRlciB0aGUgYGZhY3RvcnkoKWAgaXMgY2FsbGVkLlxuY29uc3QgSW5qZWN0b3JOb3RpZmllcjogdW5pcXVlIHN5bWJvbCA9IFN5bWJvbCgnSW5qZWN0b3JOb3RpZmllcicpO1xuXG5pbnRlcmZhY2UgUHJvdG90eXBlV2l0aEluamVjdG9yTm90aWZpZXIgZXh0ZW5kcyBPYmplY3Qge1xuICBbSW5qZWN0b3JOb3RpZmllcl0/OiBSZXBsYXlTdWJqZWN0PGJvb2xlYW4+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlSW5qZWN0b3JOb3RpZmllcklzQ2FwdHVyZWQoXG4gIHRhcmdldDogUHJvdG90eXBlV2l0aEluamVjdG9yTm90aWZpZXIgfCBQcml2YXRlSW5zdGFuY2Vcbik6IFJlcGxheVN1YmplY3Q8Ym9vbGVhbj4ge1xuICBpZiAodGFyZ2V0W0luamVjdG9yTm90aWZpZXJdKSB7XG4gICAgcmV0dXJuIHRhcmdldFtJbmplY3Rvck5vdGlmaWVyXSE7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgaW5qZWN0b3JOb3RpZmllciQgPSBuZXcgUmVwbGF5U3ViamVjdDxib29sZWFuPigxKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBJbmplY3Rvck5vdGlmaWVyLCB7XG4gICAgICBnZXQ6ICgpID0+IGluamVjdG9yTm90aWZpZXIkXG4gICAgfSk7XG4gICAgcmV0dXJuIGluamVjdG9yTm90aWZpZXIkO1xuICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlTG9jYWxJbmplY3RvckNhcHR1cmVkKHRhcmdldDogT2JqZWN0KTogdm9pZCB7XG4gIGlmIChGYWN0b3J5SGFzQmVlbkRlY29yYXRlZCBpbiB0YXJnZXQuY29uc3RydWN0b3IucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgY29uc3RydWN0b3I6IENvbnN0cnVjdG9yV2l0aERlZmluaXRpb25BbmRGYWN0b3J5ID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICAvLyBNZWFucyB3ZSdyZSBpbiBBT1QgbW9kZS5cbiAgaWYgKHR5cGVvZiBjb25zdHJ1Y3RvcltOR19GQUNUT1JZX0RFRl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBkZWNvcmF0ZUZhY3RvcnkoY29uc3RydWN0b3IpO1xuICB9IGVsc2UgaWYgKG5nRGV2TW9kZSkge1xuICAgIC8vIFdlJ3JlIHJ1bm5pbmcgaW4gSklUIG1vZGUgYW5kIHRoYXQgbWVhbnMgd2UncmUgbm90IGFibGUgdG8gZ2V0IHRoZSBjb21waWxlZCBkZWZpbml0aW9uXG4gICAgLy8gb24gdGhlIGNsYXNzIGluc2lkZSB0aGUgcHJvcGVydHkgZGVjb3JhdG9yIGR1cmluZyB0aGUgY3VycmVudCBtZXNzYWdlIGxvb3AgdGljay4gV2UgaGF2ZVxuICAgIC8vIHRvIHdhaXQgZm9yIHRoZSBuZXh0IG1lc3NhZ2UgbG9vcCB0aWNrLiBOb3RlIHRoYXQgdGhpcyBpcyBzYWZlIHNpbmNlIHRoaXMgUHJvbWlzZSB3aWxsIGJlXG4gICAgLy8gcmVzb2x2ZWQgZXZlbiBiZWZvcmUgdGhlIGBBUFBfSU5JVElBTElaRVJgIGlzIHJlc29sdmVkLlxuICAgIC8vIFRoZSBiZWxvdyBjb2RlIGFsc28gd2lsbCBiZSBleGVjdXRlZCBvbmx5IGluIGRldmVsb3BtZW50IG1vZGUsIHNpbmNlIGl0J3MgbmV2ZXIgcmVjb21tZW5kZWRcbiAgICAvLyB0byB1c2UgdGhlIEpJVCBjb21waWxlciBpbiBwcm9kdWN0aW9uIG1vZGUgKGJ5IHNldHRpbmcgXCJhb3Q6IGZhbHNlXCIpLlxuICAgIGRlY29yYXRlRmFjdG9yeUxhdGVyKGNvbnN0cnVjdG9yKTtcbiAgfVxuXG4gIHRhcmdldC5jb25zdHJ1Y3Rvci5wcm90b3R5cGVbRmFjdG9yeUhhc0JlZW5EZWNvcmF0ZWRdID0gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvY2FsSW5qZWN0PFQ+KFxuICBpbnN0YW5jZTogUHJpdmF0ZUluc3RhbmNlLFxuICB0b2tlbjogSW5qZWN0aW9uVG9rZW48VD4gfCBUeXBlPFQ+XG4pOiBUIHwgbnVsbCB7XG4gIGNvbnN0IGluamVjdG9yOiBJbmplY3RvciB8IHVuZGVmaW5lZCA9IGluc3RhbmNlW0luamVjdG9ySW5zdGFuY2VdO1xuICByZXR1cm4gaW5qZWN0b3IgPyBpbmplY3Rvci5nZXQodG9rZW4pIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZGVjb3JhdGVGYWN0b3J5KGNvbnN0cnVjdG9yOiBDb25zdHJ1Y3RvcldpdGhEZWZpbml0aW9uQW5kRmFjdG9yeSk6IHZvaWQge1xuICBjb25zdCBmYWN0b3J5ID0gY29uc3RydWN0b3JbTkdfRkFDVE9SWV9ERUZdO1xuXG4gIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIExldCdzIHRyeSB0byBnZXQgYW55IGRlZmluaXRpb24uXG4gIC8vIENhcmV0YWtlciBub3RlOiB0aGlzIHdpbGwgYmUgY29tcGF0aWJsZSBvbmx5IHdpdGggQW5ndWxhciA5Kywgc2luY2UgQW5ndWxhciA5IGlzIHRoZSBmaXJzdFxuICAvLyBJdnktc3RhYmxlIHZlcnNpb24uIFByZXZpb3VzbHkgZGVmaW5pdGlvbiBwcm9wZXJ0aWVzIHdlcmUgbmFtZWQgZGlmZmVyZW50bHkgKGUuZy4gYG5nQ29tcG9uZW50RGVmYCkuXG4gIGNvbnN0IGRlZiA9IGNvbnN0cnVjdG9yLsm1cHJvdiB8fCBjb25zdHJ1Y3Rvci7JtXBpcGUgfHwgY29uc3RydWN0b3IuybVjbXAgfHwgY29uc3RydWN0b3IuybVkaXI7XG5cbiAgY29uc3QgZGVjb3JhdGVkRmFjdG9yeSA9ICgpID0+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGZhY3RvcnkoKTtcbiAgICAvLyBDYXJldGFrZXIgbm90ZTogYGluamVjdCgpYCB3b24ndCB3b3JrIGhlcmUuXG4gICAgLy8gV2UgY2FuIHVzZSB0aGUgYGRpcmVjdGl2ZUluamVjdGAgb25seSBkdXJpbmcgdGhlIGNvbXBvbmVudFxuICAgIC8vIGNvbnN0cnVjdGlvbiwgc2luY2UgQW5ndWxhciBjYXB0dXJlcyB0aGUgY3VycmVudGx5IGFjdGl2ZSBpbmplY3Rvci5cbiAgICAvLyBXZSdyZSBub3QgYWJsZSB0byB1c2UgdGhpcyBmdW5jdGlvbiBpbnNpZGUgdGhlIGdldHRlciAod2hlbiB0aGUgYHNlbGVjdG9ySWRgIHByb3BlcnR5IGlzXG4gICAgLy8gcmVxdWVzdGVkIGZvciB0aGUgZmlyc3QgdGltZSksIHNpbmNlIHRoZSBjdXJyZW50bHkgYWN0aXZlIGluamVjdG9yIHdpbGwgYmUgbnVsbC5cbiAgICBpbnN0YW5jZVtJbmplY3Rvckluc3RhbmNlXSA9IMm1ybVkaXJlY3RpdmVJbmplY3QoXG4gICAgICAvLyBXZSdyZSB1c2luZyBgSU5KRUNUT1JgIHRva2VuIGV4Y2VwdCBvZiB0aGUgYEluamVjdG9yYCBjbGFzcyBzaW5jZSB0aGUgY29tcGlsZXJcbiAgICAgIC8vIHRocm93czogYENhbm5vdCBhc3NpZ24gYW4gYWJzdHJhY3QgY29uc3RydWN0b3IgdHlwZSB0byBhIG5vbi1hYnN0cmFjdCBjb25zdHJ1Y3RvciB0eXBlLmAuXG4gICAgICAvLyBDYXJldGFrZXIgbm90ZTogdGhhdCB0aGlzIGlzIHRoZSBzYW1lIHdheSBvZiBnZXR0aW5nIHRoZSBpbmplY3Rvci5cbiAgICAgIElOSkVDVE9SXG4gICAgKTtcblxuICAgIC8vIENhcmV0YWtlciBub3RlOiB0aGUgbm90aWZpZXIgd2lsbCBiZSBhdmFpbGFibGUgb25seSBpZiBjb25zdW1lcnMgY2FsbCB0aGUgYGVuc3VyZUluamVjdG9yTm90aWZpZXJJc0NhcHR1cmVkKClgLlxuICAgIGNvbnN0IGluamVjdG9yTm90aWZpZXIkID0gaW5zdGFuY2VbSW5qZWN0b3JOb3RpZmllcl07XG4gICAgaWYgKGluamVjdG9yTm90aWZpZXIkKSB7XG4gICAgICBpbmplY3Rvck5vdGlmaWVyJC5uZXh0KHRydWUpO1xuICAgICAgaW5qZWN0b3JOb3RpZmllciQuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgLy8gSWYgd2UndmUgZm91bmQgYW55IGRlZmluaXRpb24gdGhlbiBpdCdzIGVub3VnaCB0byBvdmVycmlkZSB0aGUgYGRlZi5mYWN0b3J5YCBzaW5jZSBBbmd1bGFyXG4gIC8vIGNvZGUgdXNlcyB0aGUgYGRlZi5mYWN0b3J5YCBhbmQgdGhlbiBmYWxsYmFja3MgdG8gYMm1ZmFjYC5cbiAgaWYgKGRlZikge1xuICAgIGRlZi5mYWN0b3J5ID0gZGVjb3JhdGVkRmFjdG9yeTtcbiAgfVxuXG4gIC8vIGBATmdNb2R1bGUoKWAgZG9lc24ndCBkb2Vzbid0IGhhdmUgZGVmaW5pdGlvbiBmYWN0b3J5LCBhbHNvIHByb3ZpZGVycyBoYXZlIGRlZmluaXRpb25zIGJ1dCBBbmd1bGFyXG4gIC8vIHN0aWxsIHVzZXMgdGhlIGDJtWZhY2AuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zdHJ1Y3RvciwgTkdfRkFDVE9SWV9ERUYsIHtcbiAgICBnZXQ6ICgpID0+IGRlY29yYXRlZEZhY3RvcnlcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlY29yYXRlRmFjdG9yeUxhdGVyKGNvbnN0cnVjdG9yOiBDb25zdHJ1Y3RvcldpdGhEZWZpbml0aW9uQW5kRmFjdG9yeSk6IHZvaWQge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGFjdHVhbGx5IHdpbGwgYmUgdHJlZS1zaGFrZW4gYXdheSB3aGVuIGJ1aWxkaW5nIGZvciBwcm9kdWN0aW9uIHNpbmNlIGl0J3MgZ3VhcmRlZCB3aXRoIGBuZ0Rldk1vZGVgLlxuICAvLyBXZSdyZSBoYXZpbmcgdGhlIGB0cnktY2F0Y2hgIGhlcmUgYmVjYXVzZSBvZiB0aGUgYFN5bmNUZXN0Wm9uZVNwZWNgLCB3aGljaCB0aHJvd3NcbiAgLy8gYW4gZXJyb3Igd2hlbiBtaWNybyBvciBtYWNyb3Rhc2sgaXMgdXNlZCB3aXRoaW4gYSBzeW5jaHJvbm91cyB0ZXN0LiBFLmcuIGBDYW5ub3QgY2FsbFxuICAvLyBQcm9taXNlLnRoZW4gZnJvbSB3aXRoaW4gYSBzeW5jIHRlc3RgLlxuICB0cnkge1xuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgZGVjb3JhdGVGYWN0b3J5KGNvbnN0cnVjdG9yKTtcbiAgICB9KTtcbiAgfSBjYXRjaCB7XG4gICAgLy8gVGhpcyBpcyBraW5kIG9mIGEgXCJoYWNrXCIsIGJ1dCB3ZSB0cnkgdG8gYmUgYmFja3dhcmRzLWNvbXBhdGlibGUsXG4gICAgLy8gdGhvIHRoaXMgYGNhdGNoYCBibG9jayB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgd2hlbiB0ZXN0cyBhcmUgcnVuIHdpdGggSmFzbWluZSBvciBKZXN0LlxuICAgIMm1Z2xvYmFsLnByb2Nlc3MgJiZcbiAgICAgIMm1Z2xvYmFsLnByb2Nlc3MubmV4dFRpY2sgJiZcbiAgICAgIMm1Z2xvYmFsLnByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBkZWNvcmF0ZUZhY3RvcnkoY29uc3RydWN0b3IpO1xuICAgICAgfSk7XG4gIH1cbn1cblxuLy8gV2UgY291bGQndmUgdXNlZCBgybXJtUZhY3RvcnlEZWZgIGJ1dCB3ZSB0cnkgdG8gYmUgYmFja3dhcmRzLWNvbXBhdGlibGUsXG4vLyBzaW5jZSBpdCdzIG5vdCBleHBvcnRlZCBpbiBvbGRlciBBbmd1bGFyIHZlcnNpb25zLlxudHlwZSBGYWN0b3J5ID0gKCkgPT4gUHJpdmF0ZUluc3RhbmNlO1xuXG4vLyBXZSBjb3VsZCd2ZSB1c2VkIGDJtcm1SW5qZWN0YWJsZURlZmAsIGDJtcm1UGlwZURlZmAsIGV0Yy4gV2UgdHJ5IHRvIGJlIGJhY2t3YXJkcy1jb21wYXRpYmxlXG4vLyBzaW5jZSB0aGV5J3JlIG5vdCBleHBvcnRlZCBpbiBvbGRlciBBbmd1bGFyIHZlcnNpb25zLlxuaW50ZXJmYWNlIERlZmluaXRpb24ge1xuICBmYWN0b3J5OiBGYWN0b3J5IHwgbnVsbDtcbn1cblxuaW50ZXJmYWNlIENvbnN0cnVjdG9yV2l0aERlZmluaXRpb25BbmRGYWN0b3J5IGV4dGVuZHMgRnVuY3Rpb24ge1xuICAvLyBQcm92aWRlciBkZWZpbml0aW9uIGZvciB0aGUgYEBJbmplY3RhYmxlKClgIGNsYXNzLlxuICDJtXByb3Y/OiBEZWZpbml0aW9uO1xuICAvLyBQaXBlIGRlZmluaXRpb24gZm9yIHRoZSBgQFBpcGUoKWAgY2xhc3MuXG4gIMm1cGlwZT86IERlZmluaXRpb247XG4gIC8vIENvbXBvbmVudCBkZWZpbml0aW9uIGZvciB0aGUgYEBDb21wb25lbnQoKWAgY2xhc3MuXG4gIMm1Y21wPzogRGVmaW5pdGlvbjtcbiAgLy8gRGlyZWN0aXZlIGRlZmluaXRpb24gZm9yIHRoZSBgQERpcmVjdGl2ZSgpYCBjbGFzcy5cbiAgybVkaXI/OiBEZWZpbml0aW9uO1xuICBbTkdfRkFDVE9SWV9ERUZdPzogRmFjdG9yeTtcbn1cblxuaW50ZXJmYWNlIFByaXZhdGVJbnN0YW5jZSB7XG4gIFtJbmplY3Rvckluc3RhbmNlXT86IEluamVjdG9yO1xuICBbSW5qZWN0b3JOb3RpZmllcl0/OiBSZXBsYXlTdWJqZWN0PGJvb2xlYW4+O1xufVxuIl19